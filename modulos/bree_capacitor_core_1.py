# -*- coding: utf-8 -*-
"""bree_capacitor_core_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15BtV-Pgoz8FxBDdWOtNuQHGlZm6CpHdM

# Funções mais importantes necessárias ao dimensionamento de capacitores de potência eixos brasileiros.

* código base traduzida da versão basic
* Desenvolvido por Bree e WMB conforme contrato.
* Todos os direitos bree
"""

import numpy as np
import math
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import os
import sys
import duckdb

con = duckdb.connect()

# #@title Cálculo com eixos brasileiros
# paper = 4.3 #@param {type:"number"} #A4
# film = 2.35 #@param {type:"number"} #A5
# oil = 2.55 #@param {type:"number"} #A6
# tensao = 7960 #@param {type:"number"} #V
# freq = 60 #@param {type:"number"} #F
# kvac = 200 #@param {type:"number"} #R
# n_coils = 15 #@param {type:"number"} #M1
# v_coil = 1592 #@param {type:"number"} #V1
# mils_paper = 0 #@param {type:"number"} #P1
# mils_film = 1 #@param {type:"number"} #B1
# gauge_al = 0.0002 #@param {type:"number"} #F9
# h_coil = 12.75 #@param {type:"number"} #T9
# lamelas_foil = 0 #@param {type:"number"} #N1
# w_foil = 18.25#@param {type:"number"} #X2
# tol_c = 1 #@param {type:"number"} #M7
# fator_espc = 1.29 #@param {type:"number"} #S8
# sobre_voltas = 1.25 #@param {type:"number"} #T7
# fator_coil = 1.22 #@param {type:"number"} #S7
# rho_papel = 1 #@param {type:"number"} #d0
# custo_papel = 1 #@param {type:"number"} #c4
# custo_filme = 4.7 #@param {type:"number"} #s0
# custo_foil = 6.1 #@param {type:"number"} #f8
# larg_foil = 19.56 #@param {type:"number"} #x3
# larg_diel = 20 #@param {type:"number"} #x4
# refugo = 3 #@param {type:"number"} #s5

#!pip install  ipdb

#import ipdb as deb
def divisor_cartela_fusein():
    '''Função para carregar os dados referentes a cartela de elos fusiveis e c '''
    caixa = pd.read_excel(path_name+'\\db\\MH 400kvar (2).xlsx', sheet_name=8,header=1)
    qc = """Select *  From caixa \
               Where P="""+str(largura)+""" and H="""+str(altura)+""""""
    caixa = con.execute(qc).df()
    return caixa
def resistores(resistor='0.23MO',serie=1,paralelo=1):
    '''Função para carregar a tabela de resistroes para montagem'''
    res = pd.read_excel(path_name+'\\db\\MH 400kvar (2).xlsx', sheet_name=6,header=1)
    res.query("Série == @serie & Paralelo == @paralelo & TP.str.contains('@resistor')",inplace=True)
    # and 'TP' LIKE '%@resistor%'
    # qc = """Select *  From res \
    #            Where res."Série"="""+str(serie)+"""\
    #                  and res."Paralelo"="""+str(paralelo)+""" \
    #                  and res."TP" LIKE '%"""\
    #                  +str(resistor)+"""%';"""\
    #                      """"""
    
    # qr = qc.replace(chr(92),"")   
                        
    # res = con.execute(qr).df()
    return res

def caixa_pintura(altura=110,largura=105):
    '''Função para carregar a tabela de caixa pintura'''
    caixa = pd.read_excel(path_name+'\\db\\MH 400kvar (2).xlsx', sheet_name=8,header=1)
    qc = """Select *  From caixa \
               Where P="""+str(largura)+""" and H="""+str(altura)+""""""
    caixa = con.execute(qc).df()
    return caixa


def calco_lateral(largura=68,espessura=3):
    '''Função para carregar a tabela de calço lateral'''
    calco = pd.read_excel(path_name+'\\db\\MH 400kvar (2).xlsx', sheet_name=7,header=0)
    qc = """Select *  From calco \
               Where calco."Largura (mm)"<="""+str(int(largura))+""" and calco."Espessura (mm)">="""+str(espessura)+""" \
               order by calco."Largura (mm)" DESC, calco."Espessura (mm)" """
    calco = con.execute(qc).df()
    return calco

def divisor(largura=120):
    '''Função para carregar a tabela de calço lateral'''
    divisor = pd.read_excel(path_name+'\\db\\MH 400kvar (2).xlsx', sheet_name=1,header=1)
    qc = """Select *  From divisor \
               Where Largura<= """+str(int(largura))+""" \
               order by Largura DESC """
    divisor = con.execute(qc).df()
    return divisor   

def placa_lateral1(altura=117.0,largura=140.0):
    '''Função para carregar a tabela de calço lateral'''
    placa = pd.read_excel(path_name+'\\db\\MH 400kvar (2).xlsx', sheet_name=4,header=1)
    qc = """Select *  From placa \
               Where placa."Código" IS NOT NULL and Altura>="""+str(int(altura))+""" and Largura>="""+str(int(largura))+""" \
               order by Altura"""
    placa = con.execute(qc).df()
    placa['Descrição'] = placa['Largura'].astype(str)+ 'mm x ' + placa['Altura'].astype(str)+ 'mm'
    return placa    

def tampa(nbi=60,largura=105,nbuchas=2):
    '''Função para carregar a tabela de tampa do capacitor'''
    tampa = pd.read_excel(path_name+'\\db\\MH 400kvar (2).xlsx', sheet_name=3,header=0)
    qc = """Select *  From tampa \
               Where NBI="""+str(int(nbi))+""" and L="""+str(largura)+""" and "n.Buchas"="""+str(nbuchas)+""""""
    tampa = con.execute(qc).df()
    return tampa    

def placa_lateral():
    '''Função para carregar a tabela de condutores do banco de dados'''
    placa_df = pd.read_excel(
        path_name+'\\db\\Placa lateral Filtro.xlsx', sheet_name=1)
    qc = """Select *  From placa_df \
               Where codigo IS NOT NULL"""
    placa_df = con.execute(qc).df()
    placa_df[['Largura', 'Altura', 'Espessura']
             ] = placa_df['Descrição'].str.split('X', expand=True)
    qc = """SELECT Codigo, placa_df."Descrição", REPLACE(Largura, 'PLACA LATERAL ', '') as Largura, Altura, \
               REPLACE(Espessura, 'MM', '') as Espessura FROM placa_df"""
    placa_df = con.execute(qc).df()
    qc = """SELECT * FROM placa_df \
               WHERE Altura IS NOT NULL AND LARGURA='140' OR LARGURA='320' OR LARGURA='326' OR LARGURA='515' \
               ORDER BY CAST(ALTURA as INT)"""
    placa_df = con.execute(qc).df()
    return placa_df


"""# Função para dimensionar capacitores eixos brasileiros."""


def cp_br(paper=4.3, film=2.35, oil=2.55, tensao=7960, freq=60, kvac=200,
          n_coils=15, v_coil=1592, mils_paper=0, mils_film=1,
          gauge_al=0.0002, h_coil=12.75, lamelas_foil=0, w_foil=18.2,
          tol_c=1, fator_espc=1.29, sobre_voltas=1.25, fator_coil=1.22,
          rho_papel=1, custo_papel=1, custo_filme=4.7, custo_foil=6.1,
          larg_foil=19.56, larg_diel=20, refugo=3, eixo=0, auto_eixo=True):
    '''Função para dimensionar capacitores de potência utilizando eixos brasileiros desenvolvido utilizando o código BASIC do progarama P0400101.BAS'''
    '''d = [5.0, 
        3.65, 3.35,
        3.12, 3.04, 2.96, 2.88, 2.8,
        2.72, 2.56, 2.48, 2.4,
        2.32, 2.24, 2.18, 2.11, 2.04,
        1.96, 1.89, 1.8, 1.72, 1.71,
        1.69, 1.63, 1.61,1.55, 1.0]'''
    d = [4.29, 4.25, 3.65, 3.35, 3.12,
         3.04, 3.01, 2.96, 2.88, 2.8,
         2.72, 2.56, 2.53, 2.48, 2.46,
         2.4, 2.32, 2.29, 2.24, 2.23,
         2.18, 2.16, 2.11, 2.04, 1.96,
         1.89, 1.85, 1.8, 1.75, 1.72, 1.71,
         1.69, 1.63, 1.61, 1.56, 1.55, 1.375]
    j = len(d)  # número de eixos

    a1 = 2230/(paper*12)
    a2 = 2230/(film*12)
    a3 = 2230/(oil*12)
    s1 = fator_espc
    g, i1, i2 = 0, 0, 0
    if auto_eixo:
        d3 = d[eixo]
        g = 1
    else:
        d3 = d[0]
    n = int(tensao/v_coil+0.5)
    for i in range(1, 101):
        m = i*n
        if m >= n_coils:
            break
    gs = n
    gp = i
    v8 = tensao/n
    c = 1e9*tol_c*n*kvac/(tensao**2*2*np.pi*freq*m/n)
    p2 = (mils_paper+mils_film)
    p3 = 0.001*p2
    t6 = (s1-1)*p2
    x5 = 1/(s1*p2)
    f2 = (a1*mils_paper+a2*mils_film+a3*t6)*x5
    l2 = c*12*f2*p2*s1/w_foil
    p4 = 2*(gauge_al+p3*s1)
    a = np.pi*fator_coil/(2*s1)
    c1 = -p4*2*l2
    i = 0
    i1 = 0
    teste = True
    if auto_eixo:
        while teste:  # i<len(d):
            if teste:
                b = np.pi*d[i]
            else:
                b = np.pi*d[i1]
            t = (-b+(np.sqrt(b**2-4*a*c1)))/(2*a)
            t5 = sobre_voltas*2*p3*s1+2*p3*s1*3/b
            t4 = t + t5
            t2 = m*t4
            if t2 > h_coil:
                i1 = i-1
                g = 1
                i2 = i1
                d3 = d[i1]
                i = i1
                b = np.pi*d[i1]
                teste = False
            else:
                i += 1
                if i > j-1:
                    teste = False
                else:
                    teste = True
    else:
        i2 = eixo
        i1 = i2
        i = i2
        b = np.pi*d[i1]
        t = (-b+(np.sqrt(b**2-4*a*c1)))/(2*a)
        t5 = sobre_voltas*2*p3*s1+2*p3*s1*3/b
        t4 = t + t5
        t2 = m*t4
        g = 1
        d3 = d[i1]
    if g == 1:
        t = (-b+(np.sqrt(b**2-4*a*c1)))/(2*a)
        t5 = sobre_voltas*2*p3*s1+2*p3*s1*3/b
        t4 = t + t5
        t2 = m*t4
        w1 = t4*fator_coil/s1
        l1 = np.pi*(d3+w1/2)
        t1 = l2/l1
        w = np.pi*d3/2+t4*fator_coil/s1
        t6 = (s1-1)*p2
        x5 = 1/(s1*p2)
        f2 = (a1*mils_paper+a2*mils_film+a3*t6)*x5
        l2 = c*12*f2*p2*s1/w_foil
        loop = True
        while loop:
            w1 = t4*fator_coil/s1
            l1 = np.pi*(d3+w1/2)
            t1 = l2/l1
            l3 = 3+np.pi*1.25*(d3+w1)+np.pi*(sobre_voltas-1.25)*d3
            t3 = (l2+l3)/l1
            s9 = 250*(t4-4*gauge_al*t1)/(t3*p2)
            y = np.abs(s9-s1)
            if y < 0.0001:
                loop = False
                t2 = m*t4
                w = np.pi*d3/2+t4*fator_coil/s1
                y0 = (500*(l2/(np.pi*t1)-d3)-1000*gauge_al*t1)/(p2*t3)
            t4 = t4*np.sqrt(s1/s9)
            if t2 > h_coil:
                i2 -= 1
                if auto_eixo:
                    d3 = d[i2]
        s1 = s9*(h_coil/t2)
        loop = True
        while loop:
            t4 = h_coil/m
            t6 = (s1-1)*p2
            x5 = 1/(s1*p2)
            f2 = (a1*mils_paper+a2*mils_film+a3*t6)*x5
            l2 = c*12*f2*p2*s1/w_foil
            w1 = t4*fator_coil/s1
            l1 = np.pi*(d3+w1/2)
            t1 = l2/l1
            l3 = 3+np.pi*1.25*(d3+w1)+np.pi*(sobre_voltas-1.25)*d3
            t3 = (l2+l3)/l1
            s9 = 250*(t4-4*gauge_al*t1)/(t3*p2)
            y = np.abs(s9-s1)
            if y < 0.0001:
                t2 = m*t4
                w = np.pi*d3/2+t4*fator_coil/s1
                y0 = (500*(l2/(np.pi*t1)-d3)-1000*gauge_al*t1)/(p2*t3)
                loop = False
            s1 = s1*np.sqrt(s9/s1)
        f1 = mils_film/(mils_film+mils_paper)
        q9 = 0
        if lamelas_foil != 0:
            q9 = l2*c*2*np.pi*freq*0.0000001/(w_foil*lamelas_foil**2)
        if paper > 4.2:
            m9 = ((1-f1)*film*0.28+f1*paper*0.003)/((1-f1)*film+f1*paper)
        else:
            m9 = ((1-f1)*film*21+f1*paper*0.003)/((1-f1)*film+f1*paper)
        if w_foil > 15:
            m8 = m9+q9+0.002+0.005
            m5 = m8*1.1
        else:
            m8 = m9+q9+0.004+0.005
            m5 = m8*1.1
    # deb.set_trace(context=20)
    if lamelas_foil != 0:
        x1 = l2/(2*lamelas_foil)
        for k in range(1, lamelas_foil+1):
            x = lamelas_foil+2*(j-1)*x1
            x = round(x)
    v7 = v_coil/(p3*s1)
    v8 = (p3*s1)-(p3-mils_paper)
    v9 = (v_coil/(p3-mils_paper))*((5.85/v8)/((2.2/(p3-mils_paper))+5.85/v8))
    g5 = mils_paper*paper/(mils_film*paper+mils_paper*film)
    g6 = g5*paper/film
    g7 = v_coil/(mils_paper+mils_film)
    m2 = 4*larg_diel*(l2+l3)*mils_film/((2*30000)+1500)
    s2 = custo_filme*m2
    m4 = 2*larg_diel*mils_paper*(l2+l3)/(9.935*30800*.9/rho_papel)
    s4 = m4*custo_papel
    m3 = 2*larg_foil*l2/(((2*20000)+6000)*0.00022/gauge_al)
    s3 = m3*custo_foil
    g1, g2, g3, g4 = 19.3, 19.3, 19.3, 0.02
    h6 = (lamelas_foil+1)*0.00074+(0.00011/25)*l2
    h7 = ((0.01289+h6)+(lamelas_foil*0.00382)+(l2*0.0000021))
    h8 = (m4*0.0024)+(m3*0.00216)+(m2*0.00219)
    h1 = (h7+h8)*1.012
    h2 = 0.161*h1
    h3 = 0.0037
    c2 = g1*h1+g2*h3+g3*h3
    c3 = g4*lamelas_foil*2
    lb_to_kg = 0.4536
    ps_total = lb_to_kg*(m2+m3+m4)
    ps_papel = lb_to_kg*m4
    ps_fim = lb_to_kg*m2
    ps_foil = lb_to_kg*m3
    pu_total = lb_to_kg*(m2+m3+m4)*m
    pu_papel = lb_to_kg*m4*m
    pu_film = lb_to_kg*m2*m
    pu_foil = lb_to_kg*m3*m
    mandril = d3
    cs_total = lb_to_kg*(s4+s2+s3)
    cs_papel = s4*lb_to_kg
    cs_fim = lb_to_kg*s2
    cs_foil = lb_to_kg*s3
    cu_total = lb_to_kg*(s2+s3+s4)*m
    cu_papel = lb_to_kg*s4*m
    cu_film = lb_to_kg*s2*m
    cu_foil = lb_to_kg*s3*m
    custo_total = (1+refugo/100)*(c2+s2+s3+s4+c3)*m*lb_to_kg
    basico = (s2+s3+s4)*m*lb_to_kg
    enrolamento = c2*m*lb_to_kg
    dry_test = (refugo/100)*m*(s2+s3+s4+c2+c3)*lb_to_kg
    lamelas = c3*m*lb_to_kg
    stress = tensao/(gs*mils_film)
    str_kv_mm = stress/25.4

    dict = {'0- Fator de espaço': [s1], '1- comp foil (in)': [l2],
            '2- comp foil (dm)': [l2*.254], '3- F. esp. bobinag.': [y0],
            '4- Voltas foil': [t1], '5-  Sobre voltas': [l3], '6- Total de bobinas': [m],
            '7- Esp. bobina (in)': [t4], '8- Esp. bobina (mm)': [t4*25.4],
            '9- Capacit/unidade': [c*m/n**2], '10- Capacit/bobina': [c],
            '11- diametro do mandril': [mandril],
            '12- Volts/bobina': [v_coil], '13- Largura (mm)': [w*25.4],
            '14- P. F. Principal': [m8], '15- 95% PF': [m5], '16- Perdas foil': [q9],
            '17- Peso total seção': [ps_total], '18- Peso papel seção': [ps_papel],
            '19- Peso filme seção': [ps_fim], '20- Peso foil seção': [ps_foil],
            '21- Peso total unidade': [pu_total], '22- Peso papel unidade': [pu_papel],
            '23- Peso filme unidade': [pu_film], '24- Peso foil unidade': [pu_foil],
            '25- Material básico': [basico], '26- Enrolamento': [enrolamento],
            '27- Dry teste': [dry_test],
            '28- Índice mandril': [int(i2)],
            '29- Potência': [kvac],
            '30- Tensão': [tensao],
            '31- Frequência': [freq],
            '32- Grupos série': [gs],
            '33- Grupos paralelo': [gp],
            '34- Stress VPM': [stress],
            '35- Stress kV/mm': [str_kv_mm],
            }
    return pd.DataFrame(dict)


"""# Teste Capacitor de potência eixos brasileiros"""

# cp_br()

"""# Função para dimensionar capacitores eixos americanos"""


def cp_en(paper=4.3, film=2.35, oil=2.55, tensao=7960, freq=60, kvac=200,
          n_coils=15, v_coil=1592, mils_paper=0, mils_film=1,
          gauge_al=0.0002, h_coil=12.75, lamelas_foil=0, w_foil=18.2,
          tol_c=1, fator_espc=1.29, sobre_voltas=1.25, fator_coil=1.22,
          rho_papel=1, custo_papel=1, custo_filme=4.7, custo_foil=6.1,
          larg_foil=19.56, larg_diel=20, refugo=3, eixo=0, auto_eixo=True):
    '''Função para dimensionar capacitores de potência utilizando eixos americanos desenvolvido utilizando o código BASIC do progarama P0400102.BAS'''
    
    d = [4.29, 4.25, 3.65, 3.35, 3.12,
         3.04, 3.01, 2.96, 2.88, 2.8,
         2.72, 2.56, 2.53, 2.48, 2.46,
         2.4, 2.32, 2.29, 2.24, 2.23,
         2.18, 2.16, 2.11, 2.04, 1.96,
         1.89, 1.85, 1.8, 1.75, 1.72, 1.71,
         1.69, 1.63, 1.61, 1.56, 1.55, 1.375]

    j = len(d)  # número de eixos
    d3 = d[0]
    a1 = 2230/(paper*12)
    a2 = 2230/(film*12)
    a3 = 2230/(oil*12)
    s1 = fator_espc
    g, i1, i2 = 0, 0, 0
    n = int(tensao/v_coil)
    for i in range(1, 101):
        m = i*n
        if m >= n_coils:
            break
    gp = i
    v8 = tensao/n
    c = 1e9*tol_c*n*kvac/(tensao**2*2*np.pi*freq*m/n)
    p2 = (mils_paper+mils_film)
    p3 = 0.001*p2
    t6 = (s1-1)*p2
    x5 = 1/(s1*p2)
    f2 = (a1*mils_paper+a2*mils_film+a3*t6)*x5
    l2 = c*12*f2*p2*s1/w_foil
    p4 = 2*(gauge_al+p3*s1)
    a = np.pi*fator_coil/(2*s1)
    c1 = -p4*2*l2
    i = 0
    i1 = 0
    if auto_eixo:
        teste = True
        while teste:  # i<len(d):
            if teste:
                b = np.pi*d[i]
            else:
                b = np.pi*d[i1]
            t = (-b+(np.sqrt(b**2-4*a*c1)))/(2*a)
            t5 = sobre_voltas*2*p3*s1+2*p3*s1*3/b
            t4 = t + t5
            t2 = m*t4
            g = 1
            if t2 > h_coil:
                i1 = i-1
                #g = 1
                i2 = i1
                d3 = d[i1]
                i = i1
                b = np.pi*d[i1]
                teste = False
            else:
                i += 1
                if i > j-1:
                    teste = False
                else:
                    teste = True
    else:
        i2 = eixo
        i1 = i2
        i = i2
        b = np.pi*d[i1]
        t = (-b+(np.sqrt(b**2-4*a*c1)))/(2*a)
        t5 = sobre_voltas*2*p3*s1+2*p3*s1*3/b
        t4 = t + t5
        t2 = m*t4
        g = 1
        d3 = d[i1]
    if g == 1:
        t = (-b+(np.sqrt(b**2-4*a*c1)))/(2*a)
        t5 = sobre_voltas*2*p3*s1+2*p3*s1*3/b
        t4 = t + t5
        t2 = m*t4
        w1 = t4*fator_coil/s1
        l1 = np.pi*(d3+w1/2)
        t1 = l2/l1
        w = np.pi*d3/2+t4*fator_coil/s1
        t6 = (s1-1)*p2
        x5 = 1/(s1*p2)
        f2 = (a1*mils_paper+a2*mils_film+a3*t6)*x5
        l2 = c*12*f2*p2*s1/w_foil
        loop = True
        while loop:
            w1 = t4*fator_coil/s1
            l1 = np.pi*(d3+w1/2)
            t1 = l2/l1
            l3 = 3+np.pi*1.25*(d3+w1)+np.pi*(sobre_voltas-1.25)*d3
            t3 = (l2+l3)/l1
            s9 = 250*(t4-4*gauge_al*t1)/(t3*p2)
            y = np.abs(s9-s1)
            if y < 0.0001:
                loop = False
                t2 = m*t4
                w = np.pi*d3/2+t4*fator_coil/s1
                y0 = (500*(l2/(np.pi*t1)-d3)-1000*gauge_al*t1)/(p2*t3)
            t4 = t4*np.sqrt(s1/s9)
            if t2 > h_coil:
                i2 -= 1
                if i2<0:
                    i2 = 0
                if auto_eixo:    
                    d3 = d[i2]
                    
        s1 = s9*(h_coil/t2)        
        loop = True
        while loop:
            t4 = h_coil/m
            t6 = (s1-1)*p2
            x5 = 1/(s1*p2)
            f2 = (a1*mils_paper+a2*mils_film+a3*t6)*x5
            l2 = c*12*f2*p2*s1/w_foil
            w1 = t4*fator_coil/s1
            l1 = np.pi*(d3+w1/2)
            t1 = l2/l1
            l3 = 3+np.pi*1.25*(d3+w1)+np.pi*(sobre_voltas-1.25)*d3
            t3 = (l2+l3)/l1
            s9 = 250*(t4-4*gauge_al*t1)/(t3*p2)
            y = np.abs(s9-s1)
            if y < 0.0001:
                t2 = m*t4
                w = np.pi*d3/2+t4*fator_coil/s1
                y0 = (500*(l2/(np.pi*t1)-d3)-1000*gauge_al*t1)/(p2*t3)
                loop = False
            s1 = s1*np.sqrt(s9/s1)
        f1 = mils_film/(mils_film+mils_paper)
        q9 = 0
        if lamelas_foil != 0:
            q9 = l2*c*2*np.pi*freq*0.0000001/(w_foil*lamelas_foil**2)
        if paper > 4.2:
            m9 = ((1-f1)*film*0.28+f1*paper*0.003)/((1-f1)*film+f1*paper)
        else:
            m9 = ((1-f1)*film*21+f1*paper*0.003)/((1-f1)*film+f1*paper)
        if w_foil > 15:
            m8 = m9+q9+0.002+0.005
            m5 = m8*1.1
        else:
            m8 = m9+q9+0.004+0.005
            m5 = m8*1.1
    # deb.set_trace(context=20)
    if lamelas_foil != 0:
        x1 = l2/(2*lamelas_foil)
        for k in range(1, lamelas_foil+1):
            x = lamelas_foil+2*(j-1)*x1
            x = round(x)
    v7 = v_coil/(p3*s1)
    v8 = (p3*s1)-(p3-mils_paper)
    v9 = (v_coil/(p3-mils_paper))*((5.85/v8)/((2.2/(p3-mils_paper))+5.85/v8))
    g5 = mils_paper*paper/(mils_film*paper+mils_paper*film)
    g6 = g5*paper/film
    g7 = v_coil/(mils_paper+mils_film)
    m2 = 4*larg_diel*(l2+l3)*mils_film/((2*30000)+1500)
    s2 = custo_filme*m2
    m4 = 2*larg_diel*mils_paper*(l2+l3)/(9.935*30800*.9/rho_papel)
    s4 = m4*custo_papel
    m3 = 2*larg_foil*l2/(((2*20000)+6000)*0.00022/gauge_al)
    s3 = m3*custo_foil
    g1, g2, g3, g4 = 19.3, 19.3, 19.3, 0.02
    h6 = (lamelas_foil+1)*0.00074+(0.00011/25)*l2
    h7 = ((0.01289+h6)+(lamelas_foil*0.00382)+(l2*0.0000021))
    h8 = (m4*0.0024)+(m3*0.00216)+(m2*0.00219)
    h1 = (h7+h8)*1.012
    h2 = 0.161*h1
    h3 = 0.0037
    c2 = g1*h1+g2*h3+g3*h3
    c3 = g4*lamelas_foil*2
    lb_to_kg = 0.4536
    ps_total = lb_to_kg*(m2+m3+m4)
    ps_papel = lb_to_kg*m4
    ps_fim = lb_to_kg*m2
    ps_foil = lb_to_kg*m3
    pu_total = lb_to_kg*(m2+m3+m4)*m
    pu_papel = lb_to_kg*m4*m
    pu_film = lb_to_kg*m2*m
    pu_foil = lb_to_kg*m3*m
    mandril = d3
    cs_total = lb_to_kg*s4+s2+s3
    cs_papel = s4*lb_to_kg
    cs_fim = lb_to_kg*s2
    cs_foil = lb_to_kg*s3
    cu_total = lb_to_kg*(s2+s3+s4)*m
    cu_papel = lb_to_kg*s4*m
    cu_film = lb_to_kg*s2*m
    cu_foil = lb_to_kg*s3*m
    custo_total = (1+refugo/100)*(c2+s2+s3+s4+c3)*m*lb_to_kg
    basico = (s2+s3+s4)*m*lb_to_kg
    enrolamento = c2*m*lb_to_kg
    dry_test = (refugo/100)*m*(s2+s3+s4+c2+c3)*lb_to_kg
    lamelas = c3*m*lb_to_kg
    gs = round(tensao/v_coil)
    stress = tensao/(gs*mils_film)
    str_kv_mm = stress/25.4
    dict = {'0- Fator de espaço': [s1], '1- comp foil (in)': [l2],
            '2- comp foil (dm)': [l2*.254], '3- F. esp. bobinag.': [y0],
            '4- Voltas foil': [t1], '5-  Sobre voltas': [l3], '6- Total de bobinas': [m],
            '7- Esp. bobina (in)': [t4], '8- Esp. bobina (mm)': [t4*25.4],
            '9- Capacit/unidade': [c*m/n**2], '10- Capacit/bobina': [c],
            '11- diametro do mandril': [mandril],
            '12- Volts/bobina': [v_coil], '13- Largura (mm)': [w*25.4],
            '14- P. F. Principal': [m8], '15- 95% PF': [m5], '16- Perdas foil': [q9],
            '17- Peso total seção': [ps_total], '18- Peso papel seção': [ps_papel],
            '19- Peso filme seção': [ps_fim], '20- Peso foil seção': [ps_foil],
            '21- Peso total unidade': [pu_total], '22- Peso papel unidade': [pu_papel],
            '23- Peso filme unidade': [pu_film], '24- Peso foil unidade': [pu_foil],
            '25- Material básico': [basico], '26- Enrolamento': [enrolamento],
            '27- Dry teste': [dry_test],
            '28- Índice mandril': [int(i2)],
            '29- Potência': [kvac],
            '30- Tensão': [tensao],
            '31- Frequência': [freq],
            '32- Grupos série': [gs],
            '33- Grupos paralelo': [gp],
            '34- Stress kV/mm': [stress],
            '35- Stress kV/mm': [str_kv_mm],
            }
    '''dict = {'0- Fator de espaço': [s1], '1- comp foil (in)': [l2],
            '2- comp foil (dm)': [l2*.254], '3- F. esp. bobinag.': [y0],
            '4- Voltas foil': [t1], '5-  Sobre voltas': [l3], '6- Total de bobinas': [m],
            '8- Esp. bobina (mm)': [t4*25.4],
            '9- Capacit/unidade': [c*m/n**2], '10- Capacit/bobina': [c],
            '11- diametro do mandril': [mandril],
            '13- Volts/bobina': [v_coil], '14- Largura (mm)': [w*25.4],
            '15- P. F. Principal': [m8], '16- 95% PF': [m5], '17- Perdas foil': [q9],
            '18- Peso total seção': [ps_total], '19- Peso papel seção': [ps_papel],
            '20- Peso filme seção': [ps_fim], '21- Peso foil seção': [ps_foil],
            '22- Peso total unidade': [pu_total], '23- Peso papel unidade': [pu_papel],
            '24- Peso filme unidade': [pu_film], '25- Peso foil unidade': [pu_foil],
            '35- Material básico': [basico], '36- Enrolamento': [enrolamento],
            '37- Dry teste': [dry_test],
            '38- Índice mandril': [int(i2)]}'''
    return pd.DataFrame(dict)


"""# Função para dimensionar capacitores eixos americanos"""

# cp_en()

"""# Função para dimensionar capacitores de alta frequência."""


def c_hf(paper=4.3, film=2.34, alum=2.55, codigo=478000, tensao=1250,
         freq=1200, kvac=133.33, esp_coil=24.438, larg_coil=130,
         esp_al=0.36, larg_max=0, larg_min=0,
         tol_c=1, esp_paper=0, custo_papel=1, esp_film=1.2, custo_filme=4.7,
         larg_ativa=11.654, fator_espc=1.18, custo_al=1):
    '''Função para dimensionar capacitores de alta frequência utilizando eixos brasileiros desenvolvido utilizando o código BASIC do progarama P0401111.BAS'''

    def sub3870(b, r7, r8, r9, c1, l1, t):
        p3 = esp_paper+b
        s2 = s1*p3
        f1 = b/s2
        f2 = (r7*esp_paper+r8*b+r9*(s1-1)*p3)/(s1*p3)
        l2 = 12*f2*s2*c1/larg_ativa
        t1 = l2/l1
        t2 = (l2+l3)/l1
        k0 = t*l1-4*esp_al*.001*l2
        c5 = larg_ativa*(250*k0-l3*s2)/(12*s2**2*f2)
        return p3, s2, f1, f2, l2, t1, t2, c5

    def sub4070():
        o1 = 1/(p1/o7+esp_film/o8+(p1+esp_film)*(s1-1)/o9)
        o2 = 1/(p1/2+esp_film/2.2+(p1+esp_film)*(s1-1)/1)
        c9 = c5*o2/o1
        #m9 = ((1-f1)*o8*.21+f1*o7*.003)/((1-f1)*o8+f1*o7)
        #m6 = m9*1.1
        v7, v8, v9, m7, g5, g6, g7, m6, m9 = stress_film()
        b1 = (kvac/n)*m6*1.1*10
        b2 = 37*b1/t/86.6
        b3 = 18*b1/t/64.5
        b4 = b1*((larg_ativa+.5)*(2.54))**2/((larg_ativa+.5)
                                             * 2.54*2.21*(esp_al/1000*2*l2*2.54*2.54*2))
        b5 = 45+b2+b4
        b6 = 45+b3+b4
        return o1, o2, c9, m9, b1, b2, b3, b4, b5, b6

    def stress_film():
        v7 = v1/(p3*s1)
        v8 = (p3*s1)-(p3-p1)
        v9 = (v1/(p3-p1))*((5.85/v8)/((2.2/(p3-p1))+(5.85/v8)))
        m7 = (v1-v9*(p3-p1))/v8
        g5 = v1*o7/(esp_film*o7+p1*o8)
        g6 = g5*o8/o7
        g7 = v1/(esp_film+p1)
        f1 = esp_film/(esp_film+esp_paper)
        m9 = ((1-f1)*o8*.21+f1*o7*.003)/((1-f1)*o8+f1*o7)
        if larg_ativa <= 15:
            m9 = m9+.01
        else:
            m9 = m9+.005
        m6 = m9*1.1
        return v7, v8, v9, m7, g5, g6, g7, m6, m9

    pol = 25.4
    larg_coil = larg_coil/pol
    esp_coil = esp_coil/pol
    s7 = 1.2
    r = 100
    d = [6.125, 4.25, 3.65, 3.12, 3.04, 2.96, 2.88, 2.80, 2.72,
         2.56, 2.48, 2.40, 2.32, 2.24, 2.18, 2.11, 2.04, 1.96,
         1.89, 1.80, 1.72, 1.71, 1.69, 1.63, 1.61, 1.55]
    o7, o8, o9, f7 = 4.3, 2.34, 2.55, 0
    m0, p4, p5, p7, g1, g2, g3, g4 = 0.25, .01, .01, .05, 10.02, 10.02, 10.02, .02
    #b = [0, 0, 0, esp_film]
    d3 = d[0]
    r7 = 2230/(paper*12)
    r8 = 2230/(film*12)
    r9 = 2230/(alum*12)
    s, v3, a0, v1 = 1, tensao, -1, tensao
    p, n, p0 = 1, 1, np.pi
    t, v2 = esp_coil, v1
    s7 = 1.2
    s1 = fator_espc
    # deb.set_trace(context=20)
    d2 = (larg_coil-s7*t/s1)/(np.pi/2)
    w1 = t*s7/s1
    n1 = 1
    z = 1
    a = 10
    for j in range(len(d)):
        a1 = np.abs(d[j]-d2)
        if a1 <= a:
            a = a1
            d3 = d[j]
            indice = j
    # deb.set_trace(context=20)
    w = np.pi*d3/2+w1
    if larg_max > 0:
        w5 = larg_max/pol
    else:
        w5 = larg_coil+.1
    if larg_min > 0:
        w4 = larg_min/pol
    else:
        w4 = larg_coil-.1
    #w4 = w4/pol
    w = np.pi*d3/2+w1
    teste = not ((w < w5) and (w > w4))
    # 1550
    # while teste:
    l1 = np.pi*(d3+w1/2)
    l3 = 3+np.pi*m0*(d3+w1)
    l3 = round(l3)
    w3 = 2*np.pi*freq
    c = tol_c*kvac*1e9/(w3*tensao**2)
    c1 = c*s/p
    #y1 = 3
    v0 = tensao/s
    l5 = esp_coil-0.004*m0*n*(esp_film+.5)
    v6 = larg_ativa*l5*(w-.214*l5/n)
    a3 = .367*esp_film-1.345*v0**2*w3*v6*1E-09/(tol_c*kvac)
    a2 = 1.56*esp_film+esp_al
    d4 = (-a2+np.sqrt(a2**2-4*a3))/2
    # 2180
    p1 = round(esp_paper*20)/20
    # 3970
    q1 = s1+.01
    q3 = .05
    q2 = q1+q3
    q4 = q3/2
    # 2260
    s1 = q1
    test = True
    while test:
        p3, s2, f1, f2, l2, t1, t2, c5 = sub3870(
            esp_film, r7, r8, r9, c1, l1, t)
        c7 = c5
        s1 = q2
        p3, s2, f1, f2, l2, t1, t2, c5 = sub3870(
            esp_film, r7, r8, r9, c1, l1, t)
        c8 = c5
        c6 = c1
        if c1/(1+p4) <= c7 or c1/(1-p5) >= c8:
            s1 = q1-q3*(c1-c7)/(c7-c8)
            c6 = c1
            if s1 <= q1:
                s1 = q1
                c6 = c7
            if s1 >= q2:
                s1 = q2
                c6 = c8
            p3 = p1 + esp_film
            f1 = esp_film/(s1*p3)
            f2 = (r7*p1+r8*esp_film+r9*(s1-1)*p3)/(s1*p3)
            l2 = 12*f2*p3*s1*c6/larg_ativa
            teste = True
            loop = 0
            while teste:
                t1 = l2/l1
                t2 = (l2+l3)/l1
                s1 = 250*(t-4*esp_al*.001*t1)/(t2*p3)
                if abs((q1+q2)/2-s1) >= q4:
                    l2 = ((1-((q1+q2)/2-s1)/5)*l2)
                    c5 = larg_ativa*l2/(12*f2*p3*s1)
                    y = (c5-c1)*100/c1
                    p6 = (p4+p5)/2
                else:
                    l4 = l2+l3
                    y0 = (500*(l2/(p0*t1)-d3)-larg_coil*t1)/(p3*t2)
                    f1 = esp_film/(p3*s1)
                    f2 = (r7*p1+r8*esp_film+r9*(s1-1)*p3)/(s1*p3)
                    c5 = larg_ativa*l2/(12*f2*p3*s1)
                    y = (c5-c1)*100/c1
                    p6 = (p4+p5)/2
                if abs(y/100) <= p6:
                    test = False
                    break
                    # a = r*1150/(tensao*p*.15)
                    # q1 = s1+.01
                    # q3 = .05
                    # q2 = q1+q3
                    # q4 = q3/2

                if abs(y/100) <= p7:
                    l2 = (1-y/200)*l2
                    teste = False
                loop += 1
                if loop > 10:
                    return 'Com os parâmetros setados não foi possível dimensionar o capacitor'
        if a0 == -1:
            o1, o2, c9, m9, b1, b2, b3, b4, b5, b6 = sub4070()
        l4 = l2+l3
        p6 = (p4+p5)/2
        a = r*1150/(tensao*p*.15)
        q1 = s1+.01
        q3 = .05
        q2 = q1+q3
        q4 = q3/2
        l2 = (1-y/200)*l2

    n2 = 2*n1
    x1 = l2/n2
    for j in range(n1):
        x = x1+2*(j-1)*x1
        x = round(x)
    v7, v8, v9, m7, g5, g6, g7, m6, m9 = stress_film()
    x3 = larg_ativa+1.25
    x4 = larg_ativa+.75
    d0 = .9
    m1 = 2*x3*p1*l4/(.935*308*100)
    f8 = 2.65
    s4 = m1*custo_papel
    m3 = 2*(larg_ativa+.75)*l2/(10250/esp_al)
    s3 = m3*custo_al
    m2 = 4*x3*l4*esp_film/(615*100)
    s2 = custo_filme*m2
    s6 = s2+s3+s4
    a4 = t*(w-t+t*p0/4)
    a5 = m0*p3*.001*s1
    t0 = s1*p3+esp_al
    e3 = larg_ativa*(a4-a5)/(t0*10.25/esp_al)
    e2 = x3*a4*esp_film/(t0*30.75)
    e1 = x3*a4*p1/(t0*.935*38.6)
    s5 = 0.03
    n3 = n*(1+s5)
    c3 = g4*n1*2
    h8 = (m1*.0024)+(m3*.00216)+(m2*.00219)
    u6 = .01426+.007
    h5 = n1
    h6 = (h5+1)*.00074+(.00011/25)*l2
    h7 = ((.01289+h6)+(h5*.00382)+(l2*.0000021))
    h8 = (m1*.002)+(m3*.0023)+(m2*.0017)
    h1 = ((h7+h8))*1.012
    h2 = .161*h1
    h3 = .0037
    c2 = g1*h1+g2*h2+g3*h3
    dict = {'kvar': [kvac], 'Frequência': [freq],
            'Largura do alumínio': [larg_ativa], 'Espessura total do alumínio': [esp_al*2],
            'Volts/unidade': [tensao], 'Volts/seção': [v1], 'Total de seçoes': [n],
            'Seções série': [s], 'Seções paralelo': [p],
            'Eixo calculado': [d2], 'Eixo utilizado': [d3],
            'Capacit/unidade': [c1], 'Capacit/bobina': [c],
            'Largura (in)': [w], 'Largura (mm)': [w*25.4],
            'Espessura do filme': [esp_film], 'Tensão por seção': [v2],
            'Espessura do papel': [esp_paper], 'Espessura da seção': [t*25.4],
            'Fator de espaço': [q1], 'Capacitância C5': [c5],
            '% DIF CAPAC. CALC': [y], 'FATOR DE ESP. BOB': [y0],
            'Fator de espaço': [q1], 'Capacitância C7': [c7],
            'Fator de espaço S1': [s1], 'Capacitância C8': [c8],
            'VOLTAS DO ALUMINIO': [t1], 'VOLTAS DO PAPEL': [t2],
            'COMP. ALUM...( DM)': [(l2-10)*25.4], 'SOBREVOLTAS': [l3],
            'Capacitância a seco C9': [c9], 'Temperatura com U coil': [b5],
            'Porcentagem de filme': [f1*100], 'Temperatura com W coil': [b6],
            'const dielt papel.:': [o7], 'const dielt óleo..:': o9,
            'const dielt filme.': [o8], 'fator de espaço...:': [fator_espc],
            'fat. esp bobinagem:': [y0], 'esp da secao (pol):': [t],
            'capac. nom. secao.': [c1], 'fat. de esp. real.:': [s1],
            'dif. na capac. (%):': [y], 'comp do alum.(pol):': [l2-10],
            'voltas do papel...:': [t2], 'comp do alum.( dm):': [pol/100*(l2-10)],
            'voltas do aluminio:': [t1], 'temp. com u coil..:': [b5],
            'temp. com w coil..:': [b6], 'papel cr$/kg......:': [custo_papel],
            'filme cr$/kg......:': [custo_filme], 'aluminio cr$/kg...:': [custo_al],
            'peso seção total....(kg):': [(m1+m2+m3)*.4536], 'peso seção total papel....(kg):': [m1*.4536],
            'peso seção total filme....(kg):': [m2*.4536], 'peso seção total Al....(kg):': [m3*.4536],
            'peso unidade total....(kg):': [(m1+m2+m3)*.4536*n], 'peso unidade total papel....(kg):': [n*m1*.4536],
            'peso unidade total filme....(kg):': [n*m2*.4536], 'peso unidade seção total Al....(kg):': [n*m3*.4536],
            'custo seção total....(kg):': [s6*.4536], 'custo seção total papel....(kg):': [.4536*s4],
            'custo seção total filme....(kg):': [s2*.4536], 'custo seção total Al....(kg):': [s3*.4536],
            'custo unidade total....(kg):': [s6*.4536*n], 'custo seção total papel....(kg):': [.4536*s4*n],
            'custo unidade total filme....(kg):': [n*s2*.4536], 'custo seção total Al....(kg):': [n*s3*.4536],
            'volts p/ mil total:': [g7], 'volts p/ mil filme:': [g5],
            'volts p/ mil papel:': [g6],
            'percent de perdas.:': [s5*100], 'custo total/unid..:': [n3*(c2+s6+c3)*.4536],
            # 'percentagem de erro no peso do aluminio...:':[100*(e3-m3)/m3],

            }
    return pd.DataFrame(dict)


# c_hf()
"""# FUSEIN

## função para dimensionar fusiveis internos.
"""


def fusein(tensao=7960, potencia=300, capacitancia=0, freq=60, tamanho=10, series=5,
           paralelo=1, conexao='Y', capac_serie=1, capac_par=1, capac_serie1=1,
           capac_serie2=1, capac_par1=7, capac_par2=7, pst=1, kurl=2.5, kmin=0.9, soma_grupos=True, num_elos=1):
    '''Função para dimensionar fusiveis desenvolvido utilizando o código BASIC do progarama FUSEIN.BAS'''
    pi = paralelo
    loop = 0
    s0 = 1
    xp = 0
    xe = 0
    xy = 0
    ue = tensao
    qe = potencia
    cr = capacitancia
    fr = freq
    typ = tamanho
    si = series
    bk = conexao
    s = capac_serie
    p = capac_par
    s1 = capac_serie1
    p1 = capac_par1
    s2 = capac_serie2
    p2 = capac_par2
    if num_elos == 1:
        rl1 = [1.1, 1.2, 1.35, 1.5, 1.6, 1.7, 1.85, 2, 2.15]
        r = [8.5, 5.8, 3.75, 2.6, 1.66, 1.07, .96, .55, .23]
        sc = [22, 30, 38, 48, 59, 70, 82, 115, 200]
        si0 = sc.copy()
        sig = [14, 19, 24.5, 30.5, 37, 42, 48, 65, 125]
        swb = [35, 52, 69, 86, 105, 130, 155, 210, 300]
        # swg = [16, 23, 31, 37, 44, 50, 45, 52, 60] # Valores alterados a caneta na tecnologia
        swg = [16, 23, 29, 34, 38, 42, 45, 52, 60]  # Valores originais
        sr = [0.082, 0.049, 0.034, 0.025, 0.02, 0.016, 0.013, 0.0088, 0.0049]
        swbm = [25, 37, 49, 61, 74, 92, 109, 147, 210]
        sigm = [11, 15, 25, 30, 34, 39, 52, 100]
        b1, b2, b3, b4, b5, b6, b7 = 0.7, 0.2, 0.8, 1, 4.5, 3, 5.5
        #sd = [0.2, 0.26, 0.31, 0.36, 0.41, 0.46, 0.51, 0.61, 0.82]
    else:
        rl1 = [1.1, 1.5, 1.9, 2.3, 2.7, 3.1, 3.5, 3.9, 4.3]
        r = [8.5, 5.8, 3.75, 2.6, 1.66, 1.07, .96, .55, .23]
        sc = [44, 60, 76, 96, 118, 140, 164, 230, 400]
        si0 = sc.copy()
        sig = [28, 38, 49, 61, 74, 84, 96, 130, 250]
        swb = [70, 104, 138, 172, 210, 260, 310, 420, 600]
        # swg = [16, 23, 31, 37, 44, 50, 45, 52, 60] # Valores alterados a caneta na tecnologia
        swg = [32, 46, 58, 68, 76, 84, 90, 104, 120]  # Valores originais
        sr = [0.0410, 0.0245, 0.0170, 0.0125,
              0.0100, 0.0080, 0.0065, 0.0044, 0.0025]
        swbm = [50, 74, 98, 122, 148, 184, 218, 294, 420]
        sigm = [22, 30, 40, 50, 60, 68, 78, 104, 200]
        b1, b2, b3, b4, b5, b6, b7 = 0.7, 0.2, 0.8, 1, 4.5, 3, 5.5
    sd = [0.2, 0.26, 0.31, 0.36, 0.41, 0.46, 0.51, 0.61, 0.82]

    rl = rl1[typ-3]

    def skr1(j1=0, aiep=0, ce=0, ueb=0, xp=0):
        # deb.set_trace(context=20)
        logs = False
        xul = kurl
        m = 0
        is1 = 0
        is2 = len(sc)
        #rs = np.zeros((10, 10))
        if j1 != 0:
            is1 = j1
            is2 = j1+1
        rs = []
        a11 = []
        a22 = []
        a33 = []
        kk = []
        siz = []
        swbb = []
        tgds = []
        kk = []
        a44 = []
        w33 = []
        sigg = []
        swbb = []
        wmb = []
        wt_wm = []
        if_i1s = []
        dict = {'Id': kk, 'Diam': rs, 'I1S': siz, 'IG': sigg, 'W0': swbb, 'WM': w33, 'IF/I1S': if_i1s,
                'IF/IG': wmb, 'WT/WM': wt_wm, 'TGDS': tgds, 'a1': a11, 'a2': a22, 'a3': a33, 'a4': a44}
        for k in range(is1, is2):
            a1 = aiep/si0[k]
            uelb = ueb/(1+(si-1)*(pi-xp)/pi)
            cel = ce*si/pi
            w2 = .000001*uelb**2*cel*(pi-xp-1)
            a2 = w2/swb[k]
            w3 = swg[k]*(1+.001*b7*rl*pi/(b6*sr[k]*si))
            a3 = w3*2*si**2/((xul*ue)**2*cel*.000001)
            a4 = sig[k]*1/(uelb*.000002*3.142*fr*cel)
            cri = np.abs(b3/(a1-b1)**b2)
            # deb.set_trace(context=20)
            if j1 == 0:
                if a1 > b1:
                    # THEN GOTO 7850
                    if a2 > cri:
                        # THEN GOTO 7890
                        if a3 > b4 and a4 >= b5:
                            # THEN GOTO 7910
                            logs = True
                            # deb.set_trace(context=20)
                            # rs.append([sd[k],a1,a2,a3,a4,tgds,w3,k,si0[k],sig[k],swb[k],w3,tgds,1/a3,tgds])
                            rs.append(sd[k])
                            tgds.append(sr[k]*2*np.pi*fr*cel*.001)
                            a11.append(a1)
                            a22.append(a2)
                            a33.append(w3)
                            kk.append(k)
                            siz.append(si0[k])
                            swbb.append(swb[k])
                            w33.append(w3)
                            a44.append(a4)
                            sigg.append(sig[k])
                            wmb.append(a1*si0[k]/sig[k])
                            if_i1s.append(a1)
                            wt_wm.append(1/a3)
                            m += 1
        return pd.DataFrame(dict)

    def felpar(p, s, pstr, xp):
        cf = ce*p/s
        uf = s*ue
        cfs = ce*p/s0
        ufs = s0*ue
        if si != 1:
            # 6830
            cep = ce*si/((si-1))
            ceb = ce*si*(pi-xp)/((pi+(si-1)*(pi-xp)))
            u0p = 0
            u0b = 0
            if bk == 'Y':
                cfp = (cep+((p/(pstr))-xe-1)*ce)/(1+(s-1)*(cep/ce+(p/(pstr))-xe
                                                           - 1)/(p/(pstr)))+ce*(p-(p/pstr))/s
                cfb = (ceb+((p/(pstr))-xe-1)*ce)/(1+(s-1)*(ceb/ce+(p/pstr)-xe-1) /
                                                  (p/pstr))+ce*(p-p/pstr)/s
                u0p = (cfp-cf)*uf/(cfp+2*cf)
                u0b = (cfb-cf)*uf/(cfb+2*cf)
                ai0b = uf*2*np.pi*fr*np.abs(cfb-cf)*.000001
                ai0p = uf*2*np.pi*fr*np.abs(cfp-cf)*.000001  # 6910
                dcfp = cfp/cf
                dcfb = cfb/cf
                aifp = (uf-u0p)*2*np.pi*fr*cfp*.000001
                aifb = (uf-u0b)*2*np.pi*fr*cfb*.000001
                aifps = aifp*(cep+((p/pstr)-xe-1)*ce)/(1+(s-1)*(cep/ce+(p/pstr) -
                                                                xe-1)/(p/pstr))/cfp
                aifbs = aifb*(ceb+((p/pstr)-xe-1)*ce)/(1+(s-1)*(ceb/ce+(p/pstr) -
                                                                xe-1)/(p/pstr))/cfb
                ueb = aifbs/(2*np.pi*1e-06*fr*(ceb+((p/pstr)-1-xe)*ce))
                aiep = aifps/(1+(ce/cep)*((p/pstr)-xe-1))  # 7000
                # print(aiep)
                # goto 7570 end function fepar
                # 7230
            elif bk == 'YHI':
                s = s1+s2
                p = p1+p2
                cf = ce*p/(s1+s2)
                uf = (s1+s2)*ue
                cfs = ce*p/s0
                pstr = p1/pst
                u0p = 0
                u0b = 0
                cfp1 = cep+(p1/pstr-xe-1)*ce/(1+(s1-1)*(cep/ce+p/pstr-xe-1) /
                                              (p1/pstr))+ce*(p1-p1/pstr)/s1
                cfb1 = (ceb+((p1/(pstr))-xe-1)*ce)/(1+(s1-1)*(ceb/ce+(p1/(pstr)) -
                                                              xe-1)/(p1/(pstr)))+ce*(p1-p1/(1*pstr))/s1
                cfp = (cep+(p/pstr-xe-1)*ce)/(1+(s-1)*(cep/ce+p/pstr-xe-1) /
                                              (p/pstr))+ce*(p-p/pstr)/s
                cfb = (ceb+((p/(1*pstr))-xe-1)*ce)/(1+(s-1)*(ceb/ce+(p/pstr)-xe-1) /
                                                    (p/pstr))+ce*(p-p/pstr)/s
                u0p = ((cfp*cfs/(cfp+cfs))-(cf*cfs/(cf+cfs)))*(uf+ufs)/((cfp*cfs /
                                                                         (cfp+cfs))+2*(cf*cfs/(cf+cfs)))
                u0b = ((cfb*cfs/(cfb+cfs))-(cf*cfs/(cf+cfs)))*(uf+ufs)/((cfb*cfs /
                                                                         (cfb+cfs))+2*(cf*cfs/(cf+cfs)))
                aifp = ((uf+ufs)-u0p)*2*np.pi*fr*(cfp*cfs/(cfp+cfs))*0.000001
                aifb = ((uf+ufs)-u0b)*2*np.pi*fr*(cfb*cfs/(cfb+cfs))*0.000001
                dcfp = cfp*(cf+cfs)/(cf*(cfp+cfs))
                dcfb = cfb*(cf+cfs)/(cf*(cfb+cfs))
                # 7390
                aifp1 = cfp1*aifp/(cfp1+(cf*s*p2/(p*s1)))
                aifp1 = cfp1*aifp/(cfp1+(cf*s*p2/(p*s1)))
                aifb1 = cfb1*aifb/(cfb1+(cf*s*p2/(p*s1)))
                aifp1s = aifp1*(cep+((p1/(pstr))-xe-1)*ce)/(1+(s1-1)*(cep/ce+(p1 /
                                                                              (pstr))-xe-1)/(p1/(pstr)))/cfp1
                aifb1s = aifb1*(ceb+((p1/(pstr))-xe-1)*ce)/(1+(s1-1)*(ceb/ce+(p1 /
                                                                              (pstr))-xe-1)/(p1/(pstr)))/cfb1
                ai0p = np.abs((cf*s*p1/(p*s2)/((cf*s*p1/(p*s2))+(cf*s*p2/(p*s2))) -
                               (cfp1)/(cfp1+(cf*s*p2/(p*s1))))*aifp)
                ai0b = np.abs((cf*s*p1/(p*s2)/((cf*s*p1/(p*s2))+(cf*s*p2/(p*s2))) -
                               (cfb1)/(cfb1+(cf*s*p2/(p*s1))))*aifb)
                ueb = aifb1s/(2*3.1415e-06*fr*(ceb+((p1/(pstr))-1-xe)*ce))
                aiep = aifp1s/(1+(ce/cep)*((p1/(pstr))-xe-1))
            elif bk == 'Y0HI' or bk == 'HI' or bk == 'DHI':
                s = s1+s2
                p = p1+p2
                cf = ce*p/(s1+s2)
                uf = (s1+s2)*ue
                cfs = ce*p/s0
                pstr = p1/pst
                u0p = 0
                u0b = 0
                xxx = p1/pstr-xe-1
                cfp1 = (cep+xxx*ce)/(1+(s1-1)*(cep/ce+xxx) /
                                     (p1/(pstr)))+ce*(p1-p1/(pstr))/s1
                cfb1 = (ceb+xxx*ce)/(1+(s1-1)*(ceb/ce+xxx) /
                                     (p1/(pstr)))+ce*(p1-p1/(pstr))/s1
                cfp = (cfp1+(cf*s*p2/(p*s1)))*((cf*s*p1/(p*s2)) +
                                               (cf*s*p2/(s2*p)))/(cfp1+(cf*s*p2/(p*s1)) +
                                                                  (cf*s*p1/(p*s2))+(cf*s*p2/(p*s2)))
                cfb = (cfb1+(cf*s*p2/(p*s1)))*((cf*s*p1/(p*s2)) +
                                               (cf*s*p2/(s2*p)))/(cfb1+(cf*s*p2/(p*s1)) +
                                                                  (cf*s*p1/(p*s2))+(cf*s*p2/(p*s2)))

                aifp = ((uf+ufs)-u0p)*2*3.142*fr*(cfp*cfs/(cfp+cfs))*.000001
                aifb = ((uf+ufs)-u0b)*2*3.142*fr*(cfb*cfs/(cfb+cfs))*.000001
                dcfp = cfp*(cf+cfs)/(cf*(cfp+cfs))
                dcfb = cfb*(cf+cfs)/(cf*(cfb+cfs))
                # print(aifp,uf,ufs,u0p,cfp,cfs)

                aifp1 = cfp1*aifp/(cfp1+(cf*s*p2/(p*s1)))
                aifb1 = cfb1*aifb/(cfb1+(cf*s*p2/(p*s1)))
                aifp1s = aifp1*(cep+xxx*ce) / \
                    (1+(s1-1)*(cep/ce+xxx)/(p1/(pstr)))/cfp1
                aifb1s = aifb1*(ceb+xxx*ce) / \
                    (1+(s1-1)*(ceb/ce+xxx)/(p1/(pstr)))/cfb1
                ai0p = abs((cf*s*p1/(p*s2)/((cf*s*p1/(p*s2)) +
                           (cf*s*p2/(p*s2)))-(cfp1)/(cfp1+(cf*s*p2/(p*s1))))*aifp)
                ai0b = abs((cf*s*p1/(p*s2)/((cf*s*p1/(p*s2)) +
                           (cf*s*p2/(p*s2)))-(cfb1)/(cfb1+(cf*s*p2/(p*s1))))*aifb)
                ueb = aifb1s/(2*3.1415e-06*fr*(ceb+xxx*ce))
                aiep = aifp1s/(1+(ce/cep)*xxx)
                #print(aifp,ueb, aiep,ueb, p1,p2,aifb1, cfp1,aifp1,uf,s, ueb,ufs,ce)

            elif bk == 'YY':
                cfp = (cep+((p1/(1*pstr))-xe-1)*ce)/(1+(s-1)*(cep/ce+(p1/(1*pstr)) -
                                                              xe-1)/(p1/(1*pstr)))+ce*(p1-p1/(pstr))/s
                cfb = (ceb+((p1/(pstr))-xe-1)*ce)/(1+(s-1) *
                                                   (ceb/ce+(p1/(pstr))-xe-1)/(p1/(pstr)))+ce*(p1-p1/(pstr))/s
                u0p = (cfp-(cf*p1/(1*p)))*uf / \
                    (cfp+2*(cf*p1/(1*p))+3*(cf*p2/(1*p)))
                u0b = (cfb-(cf*p1/(1*p)))*uf / \
                    (cfb+2*(cf*p1/(1*p))+3*(cf*p2/(1*p)))
                ai0p = np.abs(u0p*6*np.pi*fr*(cf*p2/(p))*.000001)
                ai0b = np.abs(u0b*6*np.pi*fr*(cf*p2/(p))*.000001)
                dcfp = (cfp+p2*cf/p)/cf
                dcfb = (cfb+p2*cf/p)/cf
                aifp = (uf-u0p)*2*np.pi*fr*cfp*.000001
                aifb = (uf-u0b)*2*np.pi*fr*cfb*.000001
                aifps = aifp*(cep+((p1/(1*pstr))-xe-1)*ce)/(1+(s-1) *
                                                            (cep/ce+(p1/(1*pstr))-xe-1)/(p1/(pstr)))/cfp
                aifbs = aifb*(ceb+((p1/(1*pstr))-xe-1)*ce)/(1+(s-1) *
                                                            (ceb/ce+(p1/(1*pstr))-xe-1)/(p1/(pstr)))/cfb
                ueb = aifbs/(2*np.pi*1e-6*fr*(ceb+((p1/(pstr))-1-xe)*ce))
                aiep = aifps/(1+(ce/cep)*((p1/(pstr))-xe-1))
            elif bk == 'Y0':
                u0p = 0
                u0b = 0
                cfp = (cep+((p/(1*pstr))-xe-1)*ce)/(1+(s-1) *
                                                    (cep/ce+(p/(1*pstr))-xe-1)/(p/(pstr)))+ce*(p-(p/(pstr)))/s
                cfb = (ceb+((p/(1*pstr))-xe-1)*ce)/(1+(s-1) *
                                                    (ceb/ce+(p/(1*pstr))-xe-1)/(p/(pstr)))+ce*(p-p/(pstr))/s
                ai0p = 0
                ai0b = 0
                dcfp = cfp/cf
                dcfb = cfb/cf
                aifp = (uf-u0p)*2*np.pi*fr*cfp*.000001
                aifb = (uf-u0b)*2*np.pi*fr*cfb*.000001
                aifps = aifp*(cep+((p/(pstr))-xe-1)*ce)/(1+(s-1) *
                                                         (cep/ce+(p/(pstr))-xe-1)/(p/(pstr)))/cfp
                aifbs = aifb*(ceb+((p/(pstr))-xe-1)*ce)/(1+(s-1) *
                                                         (ceb/ce+(p/(pstr))-xe-1)/(p/(pstr)))/cfb
                ueb = aifbs/(2*np.pi*1e-6*fr*(ceb+((p/(pstr))-1-xe)*ce))
                aiep = aifps/(1+(ce/cep)*((p/(pstr))-xe-1))
            elif bk == 'I' or bk == 'D':
                ai0p = 0
                ai0b = 0
                cfp = (cep+((p/(pstr))-xe-1)*ce)/(1+(s-1) *
                                                  (cep/ce+(p/(pstr))-xe-1)/(p/(pstr)))+ce*(p-(p/(pstr)))/s
                cfb = (ceb+((p/(pstr))-xe-1)*ce)/(1+(s-1) *
                                                  (ceb/ce+(p/(pstr))-xe-1)/(p/(pstr)))+ce*(p-(p/(pstr)))/s
                ai0p = np.abs(uf*2*np.pi*fr*(cfp-cf)*.000001)
                ai0b = abs(uf*2*3.1415*fr*(cfb-cf)*.000001)

                dcfp = cfp/cf
                dcfb = cfb/cf
                aifp = (uf-u0p)*2*np.pi*fr*cfp*.000001
                aifb = (uf-u0b)*2*np.pi*fr*cfb*.000001
                aifps = aifp*(cep+((p/(pstr))-xe-1)*ce)/(1+(s-1) *
                                                         (cep/ce+(p/(pstr))-xe-1)/(p/(pstr)))/cfp
                aifbs = aifb*(ceb+((p/(pstr))-xe-1)*ce)/(1+(s-1) *
                                                         (ceb/ce+(p/(pstr))-xe-1)/(p/(pstr)))/cfb
                ueb = aifbs/(2*np.pi*1e-6*fr*(ceb+((p/(pstr))-1-xe)*ce))
                aiep = aifps/(1+(ce/cep)*((p/(pstr))-xe-1))
            else:
                # deb.set_trace(context=20)
                s = s1+s2
                p = p1+p2
                cf = ce*p/(s1+s2)
                uf = (s1+s2)*ue
                pstr = p1/pst
                u0p = 0
                u0b = 0
                xxx = p1/pstr-xe-1
                cfp1 = (cep+xxx*ce)/(1+(s1-1)*(cep/ce+xxx) /
                                     (p1/(pstr)))+ce*(p1-p1/(pstr))/s1
                cfb1 = (ceb+xxx*ce)/(1+(s1-1)*(ceb/ce+xxx) /
                                     (p1/(pstr)))+ce*(p1-p1/(pstr))/s1
                cfp = (cfp1+(cf*s*p2/(p*s1)))*((cf*s*p1/(p*s2)) +
                                               (cf*s*p2/(s2*p)))/(cfp1+(cf*s*p2/(p*s1)) +
                                                                  (cf*s*p1/(p*s2))+(cf*s*p2/(p*s2)))
                cfb = (cfb1+(cf*s*p2/(p*s1)))*((cf*s*p1/(p*s2)) +
                                               (cf*s*p2/(s2*p)))/(cfb1+(cf*s*p2/(p*s1)) +
                                                                  (cf*s*p1/(p*s2))+(cf*s*p2/(p*s2)))
                # 7340 if bk$="y0hi" or bk$="hi" or bk$="dhi" then goto 7520
                dcfp = cfp/cf
                dcfb = cfb/cf
                aifp = (uf-u0p)*2*np.pi*fr*cfp*.000001
                aifb = (uf-u0b)*2*np.pi*fr*cfb*.000001
                aifp1 = cfp1*aifp/(cfp1+(cf*s*p2/(p*s1)))
                aifb1 = cfb1*aifb/(cfb1+(cf*s*p2/(p*s1)))

                aifp1s = aifp1*(cep+xxx*ce)/(1+(s1-1) *
                                             (cep/ce+xxx)/(p1/(pstr)))/cfp1
                aifb1s = aifb1*(ceb+((p1/(pstr))-xe-1)*ce)/(1+(s1-1) *
                                                            (ceb/ce+(p1/(pstr))-xe-1)/(p1/(pstr)))/cfb1
                ai0p = np.abs((cf*s*p1/(p*s2)/((cf*s*p1/(p*s2))+(cf*s*p2/(p*s2))) -
                               (cfp1)/(cfp1+(cf*s*p2/(p*s1))))*aifp)
                ai0b = np.abs((cf*s*p1/(p*s2)/((cf*s*p1/(p*s2)) +
                                               (cf*s*p2/(p*s2)))-(cfb1)/(cfb1+(cf*s*p2/(p*s1))))*aifb)

                # deb.set_trace(context=20)
                ueb = aifb1s/(2*np.pi*1e-6*fr*(ceb+xxx*ce))
                aiep = aifp1s/(1+(ce/cep)*xxx)
                #print(aiep, p1,p2,aifb1, aifp, cfp1,aifp1s,uf,s, ueb)
        return aiep, ueb
    while soma_grupos or loop == 0:
        # 7580
        ce = qe*1e9/(ue**2*2*np.pi*fr)
        qe = ce*(ue**2*2*np.pi*fr)*1E-09
        pstr = p/pst
        # 6570 felpar, 7580 skr1
        aie = 1000*qe/ue
        pw = p
        aiep, ueb = felpar(p, s, pstr, xp)
        df1 = skr1(j1=0, aiep=aiep, ce=ce, ueb=ueb, xp=xp)
        loop += 1
        if df1['Diam'].count() > 0:
            soma_grupos = False
        else:
            if soma_grupos:
                pi += 1
    ue_ue0 = []
    uel0 = []
    iel = []
    iel_ig = []
    wp_w0 = []
    wel_wm = []
    dict = {'UE/UE0': ue_ue0, 'UEL0': uel0, 'IEL': iel,
            'IEL/IG': iel_ig, 'WP/W0': wp_w0, 'WEL/WM': wel_wm}
    # deb.set_trace(context=20)
    for xp in range(pi-1):
        if xp == 0:
            j = df1['Id'][0]
            wp = df1['a2'][0]*swb[j]
            aif = df1['a1'][0]*si0[j]
        aiep, ueb = felpar(p, s, pstr, xp)
        df4 = skr1(j1=0, aiep=aiep, ce=ce, ueb=ueb, xp=xp)
        ue_ue0.append(ueb/ue)
        uelb = ueb/(1+(si-1)*(pi-xp)/pi)
        uel0.append(si*uelb/ue)
        if df4['Id'].count() > 0:
            iel.append(sig[j]/df4['a4'][0])
            iel_ig.append(1/df4['a4'][0])
            wp_w0.append(df4['a2'][0])
            wel_wm.append(df4['a2'][0]*swb[j]/(df4['WM'][0]*(pi-xp-1)))
        else:
            iel.append(sig[j]/df1['a4'][0])
            iel_ig.append(1/df1['a4'][0])
            wp_w0.append(df1['a2'][0])
            wel_wm.append(df1['a2'][0]*swb[j]/(df1['WM'][0]*(pi-xp-1)))
        # print(dict)
    df3 = pd.DataFrame(dict)
    aprv = 'Fusivies aprovados'
    dict = {'Corrente (A)': [aie], 'Capacitância (uF)': [ce],
            'Potência (kVar)': [qe],
            'Grupos série': [si], 'Grupos paralelos': [pi],
            'Conexão do banco': [bk], 'WP(kJ)': [pw*1E-09*ce*ue**2/pstr],
            'KURL': [kurl], 'KMIN': [kmin],
            'Série': [s], 'Paralelo': [p], 'Série1': [s1], 'Paralelo1': [p1],
            'Série2': [s2], 'Paralelo': [p2]}
    df2 = pd.DataFrame(dict)
    return df1, df2, df3


"""# Cálculo do resitor de descarga"""


def rs(tensao=7200, frequencia=60, potencia=200, max_p_r=3, t=300, vend=50):
    v0 = tensao
    f = frequencia
    r1 = potencia
    p9 = max_p_r
    tdes = t
    tfin = vend
    p0 = np.pi
    c = r1*1e+09/(2*p0*f*v0**2)
    x = v0*np.sqrt(2)/vend
    r = [8.50, 5.08, 3.75, 2.60, 1.66, 1.07, 0.96, 0.55, 0.23]
    r2 = tdes/(c*1.05*np.log(x))
    aa = []
    rr = []
    axri = []
    pp = []
    a110xri = []
    a90ri = []
    rr2 = []
    inicio = 0
    dict = {'Número de resitores em série': aa, 'Resistor usado': rr,
            'Restência total': axri, 'Max WATTS com 110% Vn': pp,
            '110% da Resistência total': a110xri,
            '90% da Resistência total': a90ri,
            'Resistor máximo permitido': rr2}

    def topologia(inicio=0):
        for i in range(inicio, len(r)):
            a = int(r2/r[i])
            if a >= 1:
                r4 = a*r[i]*.95
                p = (1.1*v0)**2/(r4*1000000)
                p2 = p9*a
                v1 = 3300*a
                v2 = v0*1.1
                if p2 >= p:                    
                    if v2 <= v1:
                        break
        return i, v2, a, p
    while inicio < len(r):
        i, v2, a, p = topologia(inicio)
        inicio = i+1
        teste = True
        while teste:
            b = a-1
            if b == 0:
                break
            p3 = p*a/b
            p4 = p9*b
            if p3 >= p4:
                break
            v5 = b*3300
            if v2 > v5:
                break
            a = b
            p = p3
        aa.append(a)
        rr.append(r[i])
        axri.append(a*r[i])
        pp.append(p)
        a110xri.append(1.1*a*r[i])
        a90ri.append(0.9*a*r[i])
        rr2.append(r2)
    return pd.DataFrame(dict)


"""# Resistor Serie/Paralaelo"""


def rsp(tensao=7200, frequencia=60, potencia=200, max_p_r=3, t=300, vend=50):
    v0 = tensao
    f = frequencia
    r1 = potencia
    p9 = max_p_r
    tdes = t
    tfin = vend
    p0 = np.pi
    c = r1*1e+09/(2*p0*f*v0**2)
    x = v0*np.sqrt(2)/vend
    r = [8.50, 5.08, 3.75, 2.60, 1.66, 1.07, 0.96, 0.55, 0.23]
    r2 = tdes/(c*1.05*np.log(x))
    # if v0>600:
    aa = []
    iii = []
    rr = []
    rtptt = []
    pp = []
    rtpt110 = []
    rtpt90 = []
    rr2 = []
    inicio = 0
    dict = {'Número de resitores em série': aa, 'Número de resitores em paralelo': iii,
            'Resistor usado': rr,
            'Restência total': rtptt, 'Max WATTS com 110% Vn': pp,
            '110% da Resistência total': rtpt110,
            '90% da Resistência total': rtpt90,
            'Resistor máximo permitido': rr2}

    def topologia(inicio=0):                
        for i in range(inicio,len(r)):
            #for ii in range(1,6):
            ii = 1
            while 1:             
                r3 = r[i]/ii  
                a = int(r2/r3)
                #deb.set_trace(context=20)  
                if a>=1:                
                    r4 = a*r3*.95
                    p = (1.1*v0)**2/(r4*1000000)
                    p2 = p9*a*ii
                    if p2>=p:                                      
                        v1 = 3300*a
                        v2 = v0*1.1
                        if v2<=v1:
                            break
                ii += 1        
            if p2>=p:                                      
                v1 = 3300*a
                v2 = v0*1.1
                if v2<=v1:
                    break
        return ii,i,v2,a,p 
        return ii, i, v2, a, p
    while inicio < len(r):
        ii, i, v2, a, p = topologia(inicio)
        inicio = i+1
        teste = True
        while teste:
            b = a-1
            if b == 0:
                break
            p3 = p*a/b
            p4 = p9*b
            if p3 >= p4:
                break
            v5 = b*3300
            if v2 > v5:
                break
            a = b
            p = p3
        rtpt = a*r[i]/ii
        rtpt = a*r[i]/ii
        aa.append(a)
        iii.append(ii)
        rr.append(r[i])
        rtptt.append(rtpt)
        pp.append(p)
        rtpt110.append(1.1*rtpt)
        rtpt90.append(0.9*rtpt)
        rr2.append(r2)
    return pd.DataFrame(dict)


"""# Test Resistor série"""

# rs()

"""Teste Resistor Série e Paralelo"""

# rsp()


def mi0():
    return 4e-7*np.pi


path_name = os.getcwd()
path_name = path_name = path_name.replace("\\", "/")
path_name = path_name = path_name.replace("C:", "")
path_name

# if 'content' in path_name:
#     from google.colab import drive
#     drive.mount('/content/drive')

sys.path.append(path_name)
if 'content' in path_name:
    sys.path.append('/content/drive/MyDrive/Colab Notebooks')
    os.chdir('/content/drive/MyDrive/Colab Notebooks')
else:
    sys.path.append(path_name)

"""# Função para carregar a tabela de custos do banco de dados"""


def custos():
    '''Função para carregar a tabela de condutores do banco de dados'''
    return pd.read_excel('sb2.xlsx', sheet_name=0)
