# -*- coding: utf-8 -*-
"""bree_reactor_core_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1p-90LArWe_mX5xVinnPlozHghAdo6ytm

# Funções mais importantes necessárias ao dimensionamento de reatores com núcleo de ar Bree

* Desenvolvido por Bree e WMB conforme contrato.
* Todos os direitos bree

# Carregando dataframe de condutores
"""

import numpy as np
import math
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import os
import sys


def mi0():
    return 4e-7*np.pi

#!pip install --upgrade pandas
#!pip install --upgrade xlrd
#!pip install --upgrade openpyxl
#!pip install pandoc

# from openpyxl import Workbook


path_name = os.getcwd()
path_name = path_name = path_name.replace("\\", "/")
path_name = path_name = path_name.replace("C:", "")
path_name

# if 'content' in path_name:
#     from google.colab import drive
#     drive.mount('/content/drive')

sys.path.append(path_name)
if 'content' in path_name:
    sys.path.append('/content/drive/MyDrive/Colab Notebooks')
    os.chdir('/content/drive/MyDrive/Colab Notebooks')
else:
    sys.path.append(path_name)
# sys.path.append('OneDrive/Documentos/Bree')
# sys.path.append('OneDrive/Documentos/GitHub/bree_reactor')
# sys.path.append('/content/drive/MyDrive/Colab Notebooks')
# sys.path.append('/content/drive/MyDrive/Colab Notebooks')

"""# Função para carregar a tabela de condutores do banco de dados"""


def condutores():
    '''Função para carregar a tabela de condutores do banco de dados'''
    return pd.read_excel(path_name+'\\db\\Tabelas de Fios.xlsx', sheet_name=0)


"""# Função para carregar a tabela de custos do banco de dados"""


def custos():
    '''Função para carregar a tabela de condutores do banco de dados'''
    return pd.read_excel('sb2.xlsx', sheet_name=0)


"""# Função para carregar os dados físicos químicos dos materiais"""


def materiais():
    '''Função para carregar os dados físicos químicos dos materiais'''
    return pd.read_excel(path_name+'/db/Tabelas de Fios.xlsx', sheet_name=2, engine='openpyxl')

def isoladores():
    '''Função para carregar os dados dos isoladores'''
    return pd.read_excel(path_name+'/db/ISOLADORES_202210241130.xlsm', sheet_name=0, engine='openpyxl')

m = materiais()
m


def cruzetas():
    '''Função para carregar os dados construtivos de cruzetas'''
    return pd.read_excel(path_name+'\\db\\Tabelas de Fios.xlsx', sheet_name=7, engine='openpyxl')


def fibras():
    '''Função para carregar os dados construtivos de cruzetas'''
    return pd.read_excel(path_name+'\\db\\Tabelas de Fios.xlsx', sheet_name=8, engine='openpyxl')


"""# Funções para definir colunas do dataframe cilindros"""


def axial_cil(awgs=[], axiais=[]):
    ax = 1
    if len(axiais) == 0:
        for idx, val in enumerate(awgs):
            axiais.append(ax)

    if len(awgs) > len(axiais):
        for idx, val in enumerate(axiais):
            ax = axiais[idx]
            for linha in range(len(axiais), len(awgs)):
                axiais.append(ax)
    elif len(awgs) < len(axiais):
        for deleta in range(len(axiais)-1, len(awgs)-1, -1):
            del (axiais[deleta])
    return axiais


def radial_cil(awgs=[], radiais=[]):
    rd = 4
    if len(radiais) == 0:
        for idx, val in enumerate(awgs):
            if idx == 0:
                radiais.append(rd)
            elif idx == len(awgs)-1:
                radiais.append(rd)
            else:
                radiais.append(rd-1)

    if len(awgs) > len(radiais):
        for idx, val in enumerate(radiais):
            rd = radiais[idx]
            for linha in range(len(radiais), len(awgs)):
                if idx == len(awgs)-1:
                    radiais.append(rd)
                else:
                    if rd > 1:
                        radiais.append(rd-1)
                    else:
                        radiais.append(rd)

    elif len(awgs) < len(radiais):
        for deleta in range(len(radiais)-1, len(awgs)-1, -1):
            del (radiais[deleta])
    return radiais


def fi_cil(awgs=[], fi=[], f1=2, f_any=1):
    if len(fi) == 0:
        for idx, val in enumerate(awgs):
            if idx == 0:
                fi.append(f1)
            elif idx == len(awgs)-1:
                fi.append(f_any)
            else:
                fi.append(f_any)

    if len(awgs) > len(fi):
        for idx, val in enumerate(fi):
            fi = fi[idx]
            for linha in range(len(fi), len(awgs)):
                if idx == len(awgs)-1:
                    fi.append(fi)
                else:
                    fi.append(f_any)
    elif len(awgs) < len(fi):
        for deleta in range(len(fi)-1, len(awgs)-1, -1):
            del (fi[deleta])
    return fi


def fe_cil(awgs=[], fe=[], f_last=2, f_any=1):
    if len(fe) == 0:
        for idx, val in enumerate(awgs):
            if idx == 0:
                fe.append(f_any)
            elif idx == len(awgs)-1:
                fe.append(f_last)
            else:
                fe.append(f_any)

    if len(awgs) > len(fe):
        for idx, val in enumerate(fe):
            fe = fe[idx]
            for linha in range(len(fe), len(awgs)):
                if idx == len(awgs)-1:
                    fe.append(f_last)
                else:
                    fe.append(f_any)
    elif len(awgs) < len(fe):
        for deleta in range(len(fe)-1, len(awgs)-1, -1):
            del (fe[deleta])
    return fe


def duto_cil(awgs=[], esp=[], largura=19.05):
    if len(esp) == 0:
        if len(awgs) > 1:
            for idx, val in enumerate(awgs):
                if idx == len(awgs)-1:
                    esp.append(0.0)
                else:
                    esp.append(largura)

    if len(awgs) > len(esp):
        for idx, val in enumerate(esp):
            largura = esp[idx]
            for linha in range(len(esp), len(awgs)):
                if linha == len(awgs)-1:
                    esp.append(0.0)
                else:
                    esp.append(largura)
    elif len(awgs) < len(esp):
        for deleta in range(len(esp)-1, len(awgs)-1, -1):
            del (esp[deleta])
    return esp


def rho_cil(awgs=[], rho20=0.0278980005532503):
    r_m = []
    for idx, val in enumerate(awgs):
        r_m.append(rho20)
    return r_m


def fator_folga(awgs=[], folga=1.04):
    fg = []
    for idx, val in enumerate(awgs):
        fg.append(folga)
    return fg


def densidade(awgs=[], pho=2703):
    dens = []
    for idx, val in enumerate(awgs):
        dens.append(pho)
    return dens


def kv_camada_cil(nbi, fatores, cilindros=pd.DataFrame, camadas=pd.DataFrame):
    kv_cil = []
    kv_cam = []
    cam = 0
    for index, cil in cilindros.iterrows():
        frd = int(cil['Fios radiais'])
        if index > 0:
            kv_cil.append(nbi*fatores[cam]*abs((camadas['Altura do enrolamento'].astype('float')[
                cam-1]-camadas['Altura do enrolamento'].astype('float')[cam]))/(2*max(camadas['Altura do enrolamento'].astype('float')[cam], camadas['Altura do enrolamento'].astype('float')[cam-1])))
        else:
            kv_cil.append(0)
        for layer in range(frd):
            if layer > 0:
                kv_cam.append(nbi*fatores[cam]*abs((camadas['Altura do enrolamento'].astype('float')[
                    cam-1]-camadas['Altura do enrolamento'].astype('float')[cam]))/(2*max(camadas['Altura do enrolamento'].astype('float')[cam], camadas['Altura do enrolamento'].astype('float')[cam-1])))
            else:
                kv_cam.append(0)
            cam += 1

    return kv_cil, kv_cam


"""# Função para definir a tabela de camadas a partir da tabela de cilindros"""


def camadas(di=1000, x=0, y=0, z=0, corr=120, cils=pd.DataFrame, terminal_in=1, terminal_out=0):
    """Função para definir a tabela de camadas a partir da tabela de cilindros"""
    cilindro = []
    zc = []
    camada = []
    nesp = []
    fator = []
    he = []
    hesp = []
    dm = []
    circunferencia_externa = []
    rdc = []
    i_alvo = []
    kV_nesp = []
    kV_mm = []
    kV_mm_entre_camadas = []
    V_mm = []
    r_esp = []
    peso_esp = []
    habilitado = []
    no1 = []
    no2 = []
    secao = sum(cils['area'])
    # dictionary of lists
    dict = {'Cilindro': cilindro, 'Z(mm)': zc, 'Camada': camada, '# Espiras': nesp, 'Fator de enrolamento': fator,
            'Altura da espira': hesp, 'Altura do enrolamento': he, 'Diâmetro médio': dm, 'Circunferência externa': circunferencia_externa,
            'Rdc @ 20°C (mΩ)': rdc, 'Corrente alvo(A)': i_alvo, 'Rdc Espira': r_esp, 'Peso espira': peso_esp, 'Nó cruzeta superior': no1, 'Nó cruzeta inferior': no2}
    cam = 0
    davg = di

    for index, cil in cils.iterrows():
        frd = int(cil['Fios radiais'])
        for layer in range(frd):
            cilindro.append(index)
            zc.append(z)
            camada.append(cam)
            nesp.append(10.0)
            fator.append(cil['Fator de enrolamento'])
            he.append(int(cil['Fios axiais'])*cil['dfio isol avg (mm)']
                      * 10*cil['Fator de enrolamento'])
            hesp.append(
                int(cil['Fios axiais'])*cil['dfio isol avg (mm)']*cil['Fator de enrolamento'])
            if layer == 0:
                davg = davg+2*float(cil['Fibra interna (mm)']) + \
                    cil['dfio isol avg (mm)']
            else:
                davg = davg+2*np.cos(np.pi/6)*cil['dfio isol avg (mm)']
            dm.append(davg)
            circunferencia_externa.append(
                np.pi*(davg+cil['dfio isol avg (mm)']))
            res_esp = cil['Resistividade']*np.pi*davg / \
                (int(cil['Fios axiais'])*np.pi *
                 np.square(cil['dfio nú medio (mm)'])/4)
            r_esp.append(res_esp)
            peso_esp.append(cil['Densidade']*np.pi*davg *
                            int(cil['Fios axiais'])*np.pi*cil['dfio isol avg (mm)']**2/(4*1e9))
            i_alvo.append(corr*cil['area']/(int(cil['Fios radiais'])*secao))
            rdc.append(res_esp*10)
            no1.append(terminal_in)
            no2.append(terminal_out)
            cam += 1
        print(float(cil['Fibra externa (mm)']), float(cil['Espaçadores (mm)']))
        davg = davg+cil['dfio isol avg (mm)']+2*float(
            cil['Fibra externa (mm)'])+2*float(cil['Espaçadores (mm)'])
    camadas = pd.DataFrame(dict)
    return camadas, davg, secao


"""# Função para calcular a resistencia das camadas composto de fios circulares em paralelo na axial """


def res(camada=pd.DataFrame):
    r = camada['# Espiras'].astype('float')*camada['Rdc Espira']
    return r


def fator_nao_linearidade(camada=pd.DataFrame, condutor='SW'):
    if condutor == 'SW':
        return 1.1*camada['Altura do enrolamento']/camada['Diâmetro médio']+0.923
    elif condutor == 'FTC' or condutor == 'Perfil':
        return 0.656*camada['Altura do enrolamento']/camada['Diâmetro médio']+0.850
    elif condutor == 'RS':
        return 0.849*camada['Altura do enrolamento']/camada['Diâmetro médio']+0.845


"""# Função para cálculo de mútua indutânca ou forças entre enrolamentos concéntricos ou emplihados com mesmo eixo vertical, indutância própria.

* O cálculo tanto da indutância como da mútua indutância é a partir da resoluçao da fórmula de Neumann que exigem a resolução de integrais elipticas onde método de resolução foi pelo emprego da tranformação de Bartky.
* "A fórmula de Neuwman aplicada o cáculo da mútua indutância entre dois enrolamentos concéntricos ou não concéntricos pode ser inscrita pela seguinte integral" Ref. 1.


\begin{align}
        &\ M = \mu_0n{_1}n{_2}\int_{z_2=s-l{_2}}^{z_2=s+l{_2}}\int_{z_1=-l{_1}}^{z_1=+l{_1}} \int_{0}^{pi}\frac{R{_1}R{_2}\cosθ\mathrm{d}\theta}{\sqrt{R_1²+R_2²+(z1-z_2)²}} \mathrm{d}z{_1}\mathrm{d}z{_2}
    \end{align}

>Ref. 1 Função desenvolvido a partir do paper 'THE ACCURATE COMPUTATION OF SELF AND MUTUAL INDUCTANCE OF CIRCULAR COILS' by T. H. Fawzi e P. E. Burke (IEEE Transaction on Power Apparatus and Systems, Vol. PAS -97, no. 2 , March/April 1978).

* Para entrada das dimensões em mm o resultado da indutância será em mH.
"""


def mutua(enrol1=pd.DataFrame, enrol2=pd.DataFrame, i1=0, i2=0, sinal1=1, sinal2=1, force=False):
    n1, n2 = float(enrol1['# Espiras']), float(enrol2['# Espiras'])
    d1, d2 = float(enrol1['Diâmetro médio']), float(enrol2['Diâmetro médio'])
    h1, h2 = float(enrol1['Altura do enrolamento']), float(
        enrol2['Altura do enrolamento'])
    z1, z2 = float(enrol1['Z(mm)']), float(enrol2['Z(mm)'])
    # return n1, n2, d1, d2
    if n1*n2*d1*d2 == 0:
        return 0
    dc = np.abs(z1-z2)
    r1, r2 = d1/2000, d2/2000
    z = np.array([((h1+h2)/2+dc)/1000, ((h1-h2)/2+dc)/1000, ((-h1-h2)/2+dc)/1000,
                 ((-h1+h2)/2+dc)/1000], dtype='float32')
    k, m, Ci, n = 0, 0, 0, 4
    if dc == 0:
        if r1 != r2:
            n = 2
        else:
            n = 1
    q = (r1-r2)/(r1+r2)

    for k in range(1, n+1, 1):
        zz = z[k-1]
        k2 = ((r1-r2)**2+zz**2)/((r1+r2)**2+zz**2)
        gama = zz**2/(4*r1*r2)
        A = math.sqrt(1-k2)*(-gama+1/(3*(1-k2)))
        B = -k2/(3*math.sqrt(1-k2))
        C = gama*math.sqrt(1-k2)
        if not force:
            if r1 == r2:
                A, B, C = A+C, B+C, 0
        else:
            A, B, C = -1, 0, 1
            if r1 == r2:
                A, B, C = 0, 1, 0
        d = 0
        alfa0, beta0, q0 = 1, math.sqrt(k2), abs(q)
        alfaj, betaj, qj = alfa0, beta0, q0
        A0, B0, C0, D0 = A, B, C, 0
        AJ, BJ, CJ, DJ = A0, B0, C0, D0
        loop = 0
        teste = False
        erro = 1
        while not (teste):
            alfaj = alfa0+beta0
            betaj = 2*math.sqrt(alfa0*beta0)
            AJ = B0/alfa0+A0
            BJ = 2*(B0+beta0*A0)
            CJ = 0
            DJ = 0
            if q0 != 0:
                qj = q0+alfa0*beta0/q0
                CJ = C0+D0/q0
                DJ = 2*(alfa0*beta0*C0/q0+D0)
            erro = abs(1-betaj/alfaj)
            teste = (abs(erro) <= 1e-15)
            if not teste:
                alfa0 = alfaj
                beta0 = betaj
                q0 = qj
                A0 = AJ
                B0 = BJ
                C0 = CJ
                D0 = DJ
            loop += 1
        if force:
            Ci = ((alfaj*AJ+BJ)/(2*alfaj**2)+(CJ*alfaj+DJ)/(alfaj*(alfaj+qj))) *\
                np.cos((k+1)*np.pi)*3*np.pi**2/16*zz*np.sqrt((1-k2)/(r1*r2))+Ci
        else:
            Ci = ((AJ*alfaj+BJ)/(2*alfaj**2)+(CJ*alfaj+DJ)/(alfaj*(alfaj+qj)))\
                * np.cos((k+1)*np.pi)+Ci
        # print(Ci, erro)
    if not force:
        if dc == 0:
            if r1 != r2:
                return np.cos((sinal1-sinal2)*np.pi/180)*16*np.pi**2*n1/h1 *\
                    n2/h2*np.power(r1*r2, 1.5)*Ci*100  # , loop, erro
            else:
                return np.cos((sinal1-sinal2)*np.pi/180)*16*np.pi**2*n1/h1 *\
                    n2/h2*np.power(r1*r2, 1.5)*(Ci-2/(3*np.pi)) * \
                    100  # , loop, erro
        else:
            return np.cos((sinal1-sinal2)*np.pi/180)*8*np.pi**2*n1/h1*n2/h2 *\
                (r1*r2)**1.5*Ci*100  # , loop, erro
    else:
        return np.abs(0.4*np.pi*i1*i2*n1*n2/(9.8*h1*h2)*Ci)

def total_force():
    pass

def force(enrol1=pd.DataFrame, enrol2=pd.DataFrame, i1=0, i2=0, sinal1=1, sinal2=1, u=0, s=0, force=False):
    ''' Cálculo da força entre enrolamentos com distância entre eixos s e distância entre centros u 
    Ref. Electrical Coil and Coductors BY HERBERT BRISTOL DWIGHT Pag 312 e 313'''
    def invs(e=0):
        return 1/s1**e-1/s2**e-1/s3**e+1/s4**e

    def invs2(e=0):
        return (u+m)/s1**e-(u-n)/s2**e-(u+n)/s3**e+(u-m)/s4**e

    n1, n2 = float(enrol1['# Espiras']), float(enrol2['# Espiras'])
    d1, d2 = float(enrol1['Diâmetro médio']), float(enrol2['Diâmetro médio'])
    h1, h2 = float(enrol1['Altura do enrolamento']), float(
        enrol2['Altura do enrolamento'])
    #z1, z2 = float(enrol1['Z(mm)']), float(enrol2['Z(mm)'])
    #s = np.abs(z1-z2)
    t1, t2 = float(enrol1['Espessura']), float(enrol2['Espessura'])
    # return n1, n2, d1, d2
    if n1*n2*d1*d2 == 0:
        return 0
    a1 = d1/2
    a2 = d2/2
    m = (h1+h2)/2
    n = (h1-h2)/2
    s1 = np.sqrt(s*s+(u+m)**2)
    s2 = np.sqrt(s*s+(u-n)**2)
    s3 = np.sqrt(s*s+(u+n)**2)
    s4 = np.sqrt(s*s+(u-m)**2)
    aa1 = 1+t1*t1/(12*a1**2)
    aa2 = 1+t2*t2/(12*a2**2)
    aaa1 = 1+t1**2/(2*a1**2)+t1**4/(80*a1**4)
    aaa2 = 1+t2**2/(2*a2**2)+t2**4/(80*a2**4)
    daa1 = 1+5*t1**2/(4*a1**2)+3*t1**4/(16*a1**4)+t1**6/(448*a1**6)
    daa2 = 1+5*t2**2/(4*a2**2)+3*t2**4/(16*a2**4)+t2**6/(448*a2**6)
    Fr = np.pi**2*a1**2*a2**2*i1*i2*n1*n2/(98100000*h1*h2)*(s*invs(3)*aa1*aa2-3/8*(4*s*invs(5) -
                                                                                   5*s**3*invs(7))*(a1**2*aaa1*aa2+a2*a2*aa1*aaa2)+15/64*(8*s*invs(7) -
                                                                                                                                          28*s**3*invs(9)+21*s**5*invs(11))*(a1**4*daa1*aa2+3*a1*a1*a2*a2*aaa1*aaa2 +
                                                                                                                                                                             a2**4*aa1*daa2))
    Fz = np.pi**2*a1**2*a2**2*i1*i2*n1*n2/(98100000*h1*h2)*(invs2(3)*aa1*aa2-3/8*(2*invs2(5) -
                                                                                  5*s*s*invs2(7))*(a1*a1*aaa1*aa2+a2*a2*aa1*aaa2)+5/64*(8*invs2(7) -
                                                                                                                                        56*s*s*invs2(9)+63*s**4*invs2(11))*(a1**4*daa1*aa2+3*a1*a1*a2*a2*aaa1*aaa2 +
                                                                                                                                                                            a2**4*aa1*daa2))
    return Fr, Fz
#!pip install pixiedust
# import pixiedust

#!pip install  ipdb

# import ipdb as deb


"""# Função para encontrar o número de espiras e montar a matriz de indutância e resistência.

* Φ = LxI onde L é a indutância do reator e I a corrente total.
Uma vez que todas as camadas de cada módulo estão conectadas em paralelo o fluxo magnético Φ = L1×I1 = L2×I2 = ...Ln×In do mesmo jeito pela lei de faraday temos que $\dfrac{dΦ}{dt}=v(t)$ então $v(t)$=L$\dfrac{di}{dt}$ ou ainda para uma corrente senoidal $i(t)$=Imax×$sin(𝜔t)$ teremos como resultado da derivida $v(t)=ωL×Imax×cos(ωt)$.
* A função foi preparada para atingir o número de espiras que obtenha indutâncias equivaletes por camada que gerem uma distribuição de corrente AC equivalente a distruição de corrente DC como em DC é determinada pela resistência de cada camada esta é utilizada como meta ser atingida.
"""

# from numpy.core.fromnumeric import mean
# %%pixie_debugger
# import pdb
# from fractions import *


def equilibrio(camadas=pd.DataFrame, ind_alvo=147, nbr=6, equilibrar=True):
    # deb.set_trace(context=20)
    '''Função para encontrar o número de espiras, montar a matriz de indutância e resistência em função do fluxo magnético que 
    deve ser igual indepedentemente uma vez que o fluxo Ltarget x Itotal  deve ser igual L1I1, L2I2...LnIn'''
    ncam = len(camadas)
    not_target = True
    loop = 0
    rdc_esp = camadas['Rdc Espira'].copy()
    itot = sum(camadas['Corrente alvo(A)'])
    fluxo = ind_alvo*itot
    while not_target and loop < 100:
        rdc = res(camadas)
        rdc_tot = 1/sum(1/rdc)
        itarget = itot*rdc_tot/rdc
        M = np.zeros((ncam, ncam))
        R = np.zeros((ncam, ncam))
        ind = np.zeros((ncam))
        nesp = camadas['# Espiras'].values
        altura = camadas['Altura do enrolamento'].values
        camadas['Rdc(mΩ)'] = rdc.copy()
        for i in range(ncam):
            R[i, i] = camadas['Rdc(mΩ)'][i]
            for j in range(i, ncam):
                M[i, j] = mutua(camadas.iloc[i], camadas.iloc[j])
                if i != j:
                    M[j, i] = M[i, j]
        fluxos = np.dot(M, itarget)
        erros = np.abs((fluxos/fluxo-1)*100)
        if max(erros) > 0.1 and equilibrar:
            nesp = fluxo/fluxos*camadas['# Espiras']
            nesp = np.ceil(nesp)+(np.ceil(nesp % 1*nbr))/nbr
            altura = nesp*camadas['Altura da espira']
            not_target = True
        else:
            not_target = False
        camadas['# Espiras'] = nesp.copy()
        camadas['Altura do enrolamento'] = altura.copy()
        camadas['Rdc(mΩ)'] = rdc
        camadas['Corrente alvo(A)'] = itarget
        ind = fluxos/itarget
        ind_calc = 1/(sum(1/ind))
        if np.abs(ind_calc/ind_alvo-1) < 0.01:
            not_target = False
        loop += 1
    return M, R, ind_calc, ind, fluxo, itarget

# from numpy.core.fromnumeric import mean
# %%pixie_debugger
# import pdb
# from fractions import *

def equ_hibr(R=np.array, M=np.array,l1=0.0,camadas=pd.DataFrame, taps=pd.DataFrame,dbs=0.0,dbs_mod_tap=0,altura1=0.0, localiz='',sinal=1,harms=pd.DataFrame,equilibrar=True):
    '''Função para encontrar o número de espiras da seção de taps ou reator aberto.'''
    
    itot = sum(camadas['Corrente alvo(A)'])
    itarget = camadas['Corrente alvo(A)']
    M_copy = np.copy(M)   
    R_copy = np.copy(R)    
    ncam = len(camadas)
    ntaps = len(taps)
    # nesp = taps['# Espiras'].astype('float')
    for tap in range(ntaps):
        not_target = True
        loop = 0
        while not_target and loop < 20:
            lalvo = taps['Lalvo(mH)'][tap] 
            dl_alvo = lalvo-l1            
            taps['# Espiras'][tap] = float(taps['# Espiras'][tap])
            taps['Altura da espira'][tap] = float(taps['Altura da espira'][tap])
            he = taps['# Espiras'][tap]*taps['Altura da espira'][tap]
            taps['Altura do enrolamento'][tap] = he
            ltap = mutua(taps.iloc[tap], taps.iloc[tap],0,0,sinal,sinal)
            #rdc = res(tap)
            rdc = float(taps['# Espiras'][tap])*taps['Rdc Espira'][tap]
            taps['Rdc @ 20°C (mΩ)'][tap] = rdc
            for i, cam in camadas.iterrows():        
                R[i, i] = R_copy[i,i] + rdc           
                if localiz == 'Acima da cruzeta superior':
                    zc = altura1/2+he/2+dbs_mod_tap
                elif localiz == 'Satetlite por baixo da cruzeta superior':
                    zc = dbs/2-he/2-dbs_mod_tap
                elif localiz == 'Satétile acima da cruzeta inferior':
                    zc = -dbs/2+he/2+dbs_mod_tap
                elif localiz == 'Abaixo da cruzeta inferior':
                    zc = -altura1/2-he/2-dbs_mod_tap
                taps['Z(mm)'][tap] = zc
                mut_ind = mutua(cam, taps.iloc[tap],0,0,sinal,sinal)
                M[i,i] = ltap+M_copy[i,i]+2*mut_ind
                for j in range(i+1, ncam):
                    M[i,j] = M_copy[i,j]+mut_ind+ltap
                    M[j,i] = M[i,j]
            fluxos = np.dot(M, itarget) 
            ind = fluxos/itarget
            ind_calc = 1/(sum(1/ind))#+ltap 
            dl_calc = ind_calc-l1
            R, X, Z, V, I = mesh(ind=lalvo, M=M, R=R, harms=harms, modulos=camadas)
            #zs = V/I
            z = V[0]/sum(I)
            x = z.imag
            ind_calc_mesh = x*1000/(2*np.pi*harms['freq (Hz)'][0])#+ltap
            taps['Lcalc(mH)'][tap] = ind_calc_mesh
            taps['Erro(%)'][tap] = np.abs(ind_calc_mesh/lalvo-1)*100
            #if np.abs(dl_calc/dl_alvo-1)*100<1:
            #if np.abs(ind_calc/lalvo-1)*100<0.1:
            erro = taps['Erro(%)'][tap]
            if erro > 1 and equilibrar:
                nesp = float(taps['# Espiras'][tap])*lalvo/ind_calc_mesh
                taps['# Espiras'][tap] = nesp
                not_target = True
            else:
                not_target = False
            # if not(equilibrar):
            #     not_target = False
            # if erro<1 or not(equilibrar):
            #     tap['Lcalc(mH)'] = ind_calc_mesh
            #     tap['Erro(%)'] = np.abs(ind_calc_mesh/lalvo-1)*100
            #     tap['Ltap(mH)'] = ltap
            #     not_target = False
            # else:
            #     if not_target:
            #         nesp = float(tap['# Espiras'])*lalvo/ind_calc_mesh
            #         tap['# Espiras'] = nesp
            #     not_target = True
            loop += 1  
        m = (ind_calc_mesh-l1-ltap)/2
        taps['M(mH)'][tap] = m
        nesp = taps['# Espiras'][tap] 
    return ind_calc_mesh, ltap,m,nesp,he


def equilibrio2(camadas=pd.DataFrame, ind_alvo=147, nbr=6, equilibrar=True):
    # deb.set_trace(context=20)
    '''Função para encontrar o número de espiras, montar a matriz de indutância e resistência em função do fluxo magnético que 
    deve ser igual indepedentemente uma vez que o fluxo Ltarget x Itotal  deve ser igual L1I1, L2I2...LnIn'''
    ncam = len(camadas)
    not_target = True
    loop = 0
    rdc_esp = camadas['Rdc Espira'].copy()
    rdc_tot = 1/sum(1/rdc_esp)
    itot = sum(camadas['Corrente alvo(A)'])
    itarget = camadas['Corrente alvo(A)']
    fluxo = ind_alvo*itot
    while not_target and loop < 20:
        rdc = res(camadas)
        rdc_tot = 1/sum(1/rdc)
        # itarget = itot*rdc_tot/rdc
        M = np.zeros((ncam, ncam))
        R = np.zeros((ncam, ncam))
        ind = np.zeros((ncam))
        nesp = camadas['# Espiras'].values
        altura = camadas['Altura do enrolamento'].values
        camadas['Rdc(mΩ)'] = rdc.copy()
        for i in range(ncam):
            R[i, i] = camadas['Rdc(mΩ)'][i]
            for j in range(i, ncam):
                M[i, j] = mutua(camadas.iloc[i], camadas.iloc[j])
                if i != j:
                    M[j, i] = M[i, j]
        fluxos = np.dot(M, itarget)
        erros = np.abs((fluxos/fluxo-1)*100)
        if max(erros) > 0.1 and equilibrar:
            nesp = fluxo/fluxos*camadas['# Espiras']
            nesp = np.ceil(nesp)+(np.ceil(nesp % 1*nbr))/nbr
            altura = nesp*camadas['Altura da espira']
            not_target = True
        else:
            not_target = False
        camadas['# Espiras'] = nesp.copy()
        camadas['Altura do enrolamento'] = altura.copy()
        camadas['Rdc @ 20°C (mΩ)'] = rdc
        camadas['Corrente alvo(A)'] = itarget
        ind = fluxos/itarget
        ind_calc = 1/(sum(1/ind))
        loop += 1
    return M, R, ind_calc, ind, fluxo, itarget


"""# Função para calcular a distribuição corrente a partir da matriz de indutância, matriz de resistência e dataframe de corrente utilizando o método MNA.

"""


def mna(M=np.array, R=np.array, harms=[pd.DataFrame], modulos=[pd.DataFrame]):
    '''Função para calcular a distribuição corrente a partir da matriz de indutância, matriz de resistência e dataframe de corrente.'''
    ncomp = 0
    maior_no = 0
    for camadas in modulos:
        ncomp += camadas.shape[0]
        terminais = camadas[["Nó cruzeta superior", "Nó cruzeta inferior"]]
        terminais = terminais.max().max()
        if terminais > maior_no:
            maior_no = terminais
    ncomp += maior_no

    MNA = np.ones((ncomp, ncomp), dtype=float)
    '''for camadas in moulos:
        for camada in camadas:
            MNA['''
    idx = 0
    for index, harm in harms.iterrows():
        f = harm['freq (Hz)']
        rms = harm['RMS (A)']

    return MNA, maior_no, ncomp, idx


"""# Função para calcular a distribuição corrente a partir da matriz de indutância, matriz de resistência e dataframe de corrente utilizando o método de malhas onde:

"""


def mesh(ind=1, M=np.array, R=np.array, harms=pd.DataFrame, modulos=pd.DataFrame):
    '''Função para calcular a distribuição corrente a partir da matriz de indutância, matriz de resistência e dataframe de corrente.'''
    V = np.ones((M.shape[0]), dtype='float64')
    for index, harm in harms.iterrows():
        f = harm['freq (Hz)']
        rms = harm['RMS (A)']
        X = M.copy()*(0+1j)*2*np.pi*f/1000
        Z = R/1000+X
        V = V*rms*2*np.pi*f*ind/1000
        I = np.linalg.solve(Z, V)
        modulos['RMS (A)'] = np.abs(I)
        modulos['Ângulo'] = np.angle(I, deg=True)
        modulos['Corrente (A)'] = I.astype(complex)
        modulos['Erro (%)'] = (modulos['RMS (A)'] /
                               modulos['Corrente alvo(A)']-1)*100
        modulos['Perdas (W)'] = modulos['RMS (A)']**2*modulos['Rdc(mΩ)'] / 1000
    return R, X, Z, V, I


"""# Perdas induzidas no enrolamento."""


def perdas_induzidas(cils=pd.DataFrame, res=pd.DataFrame):

    return cils

# input_cils = pd.read_excel('Prototipo.xlsx',sheet_name=0, engine='openpyxl')
# res_cils = pd.read_excel('Prototipo.xlsx',sheet_name=3, engine='openpyxl')
# perdas_induzidas(input_cils, res_cils)

# cams = pd.read_excel(path_name+'/bree prototipo Di = 1200 mm.xlsx',sheet_name=1, engine='openpyxl')
# cams = pd.read_excel('/Users/wmeba/OneDrive/Documentos/WMB/GitHub/bree prototipo Di = 1200 mm.xlsx',sheet_name=1, engine='openpyxl')
# cams = pd.read_excel('bree prototipo Di = 1200 mm.xlsx',sheet_name=1, engine='openpyxl')
# cams[['Cilindro', '# Espiras','Rdc(mΩ)']]

# M, R, ind_calc, ind, flx, itarget = equilibrio(cams,ind_alvo=1.45, equilibrar=True)
# cams[['Cilindro', '# Espiras','Rdc(mΩ)']]


rms_s = [1200]
freqs = [60]
# dictionary of lists
dict = {'RMS (A)': rms_s, 'freq (Hz)': freqs}
harms = pd.DataFrame(dict)
harms

# R, X, Z, V, I = mesh(ind=ind_calc,M=M,R=R,harms=harms,modulos=cams)
# cams[['RMS (A)', 'Ângulo','Rdc(mΩ)', 'Perdas (W)','Erro (%)']]


# mna(M=M,R=R,harms=harms,modulos=[cams])

# G = np.linalg.inv(R)
# G

# corrs = correntes()
# print(corrs)
def string_cruz(nome):
    query = """SELECT * FROM cruzetas  \
            WHERE cruzetas."Formação" LIKE """ + "'"+nome+"'" + """ 
            """
    return query


def string_camadas():
    query = """SELECT * FROM camadas  \
            ORDER BY camadas."Camada" 
            """
    return query


def string_cond(classe=130):
    query = """SELECT  condutores.TOTVS,condutores.AWG \
       FROM condutores \
       WHERE condutores."# condutores"=1 AND condutores.Classe="""+str(classe)+""" \
       ORDER BY condutores."dfio nú medio (mm)" 
       """
    return query

def string_cil_peso_espc():
    query = """SELECT *, cilindros.'Diâmetro médio'+cilindros.'Espessura'+cilindros.'Fibra externa (mm)'*2 as Ds FROM cilindros"""
    return query
def string_cil_cond(classe=130, awg=11.5):
    query = """SELECT  condutores.TOTVS,condutores.AWG,* \
       FROM condutores \
       WHERE condutores.AWG<= """+str(awg)+""" AND condutores."# condutores"=1 AND condutores.Classe="""+str(classe)+""" \
       ORDER BY condutores."dfio nú medio (mm)" 
       """
    return query


"""# String query para performa o LEFT JOIN entre o dataframa de cilindros e o dataframe dos condutores"""


def string_join_cil_cond(classe=130):
    query = """SELECT cilindros."Cilindro",cilindros."condutor AWG",cilindros."Fios axiais",
       cilindros."Fios radiais",cilindros."Fibra interna (mm)",cilindros."Fibra externa (mm)",cilindros."Espaçadores (mm)",
       cilindros."Fator de enrolamento",cilindros."Resistividade", cilindros."Densidade",condutores."dfio isol avg (mm)",
       condutores."dfio nú medio (mm)",
       condutores."Seção condutora avg (mm2)"*CAST(cilindros."Fios radiais" as SMALLINT)*CAST(cilindros."Fios axiais" as SMALLINT) AS area,
       condutores."dfio isol avg (mm)"*0.866025403784439*(CAST(cilindros."Fios radiais" AS SMALLINT)-1)+condutores."dfio isol avg (mm)" +CAST(cilindros."Fibra interna (mm)" AS DOUBLE)+
       CAST(cilindros."Fibra externa (mm)" AS DOUBLE)+CAST(cilindros."Espaçadores (mm)" AS DOUBLE) as espessura
       \
       FROM cilindros LEFT JOIN condutores         
       ON cilindros."condutor AWG"= condutores.AWG AND condutores."# condutores"=1 AND condutores.Classe="""+str(classe)+""" 
       ORDER BY Cilindro"""
    return query


def string_group_by_produto():
    return """SELECT  custos.Produto, 
       SUM(custos."Saldo Atual") AS SALDO,
       AVG(custos."C Unitario") AS custo    
       FROM custos
       GROUP BY custos.Produto"""


def string_join_cil_custo():
    return """SELECT  custos.Produto, 
       custos.custo, * 
       FROM cilindros LEFT JOIN custos
       ON cilindros.TOTVS= custos.Produto"""


def string_join_cil_cond_old(classe=130):
    return """SELECT  condutores.'dfio nú medio (mm)'*condutores.'dfio nú medio (mm)'/4*3.14159265358979 AS area,
       condutores.'dfio isol avg (mm)'*0.866025403784439*(cilindros.'Fios radiais'-1)+condutores.'dfio isol avg (mm)'+cilindros.'Fibra interna (mm)'+
       cilindros.'Fibra externa (mm)'+cilindros.'Espaçadores (mm)' as espessura,
       * 
       FROM cilindros LEFT JOIN condutores
       ON cilindros.'condutor AWG'= condutores.'AWG' AND condutores.'# condutores'=1 AND condutores.Classe="""+str(classe)+""" 
       """


def query_material(material='Al'):
    query = "SELECT * \
        FROM materiais \
        WHERE materiais.Material LIKE '"+material + "'"
    return query


def query_group_by_cil():
    return """SELECT camadas.Cilindro, AVG(camadas."# Espiras") AS Nesp, AVG(camadas."Altura do enrolamento") AS He,    
       AVG(camadas."Diâmetro médio") AS Dm, SUM(camadas."Corrente (A)") AS Corrente, 
       SUM(camadas."Perdas (W)") AS Perdas (W)
       FROM camadas
       GROUP BY camadas.Cilindro
       """


"""# Fatores de correção para o aquecimento e para rigides dielétrica devido a altitude de acordo com a norma a ser utilizada."""


def corr_fact(altitude=1000, norma="NBR 5119 - Reator"):
    '''Função para determinar os valores de correções devido ã altitude saída tupla onde o primeiro valor é o fator dielétrico e o segundo o fator térmico'''
    if altitude > 1000:
        if norma[0] == 'A':
            CorrecaoDieLetrica = 1+0.01*(altitude-1000)/100
            CorrecaoTermica = 1+0.003*(altitude-1000)/100
        elif (norma[0] == 'I') | (norma[0] == 'N'):
            CorrecaoDieLetrica = 1+0.0625*(altitude-1000)/500
            CorrecaoTermica = np.sqrt(1+0.025*(altitude-1000)/500)
        else:
            CorrecaoDieLetrica, CorrecaoTermica = 1, 1
    else:
        CorrecaoDieLetrica, CorrecaoTermica = 1, 1
    return CorrecaoDieLetrica, CorrecaoTermica


corr_fact(altitude=3000, norma="ANSI")

corr_fact(altitude=3000, norma="NBR 5119 - Reator")

corr_fact(altitude=1000, norma="ANSI")

"""# Função para cálculo de mútua indutânca ou forças entre enrolamentos concéntricos ou emplihados com mesmo eixo vertical, indutância própria.

* O cálculo tanto da indutância como da mútua indutância é a partir da resoluçao da fórmula de Neumann que exigem a resolução de integrais elipticas onde método de resolução foi pelo emprego da tranformação de Bartky.
* "A fórmula de Neuwman aplicada o cáculo da mútua indutância entre dois enrolamentos concéntricos ou não concéntricos pode ser inscrita pela seguinte integral" Ref. 1.


\begin{align}
        &\ M = \mu_0n{_1}n{_2}\int_{z_2=s-l{_2}}^{z_2=s+l{_2}}\int_{z_1=-l{_1}}^{z_1=+l{_1}} \int_{0}^{pi}\frac{R{_1}R{_2}\cosθ\mathrm{d}\theta}{\sqrt{R_1²+R_2²+(z1-z_2)²}} \mathrm{d}z{_1}\mathrm{d}z{_2}
    \end{align}

>Ref. 1 Função desenvolvido a partir do paper 'THE ACCURATE COMPUTATION OF SELF AND MUTUAL INDUCTANCE OF CIRCULAR COILS' by T. H. Fawzi e P. E. Burke (IEEE Transaction on Power Apparatus and Systems, Vol. PAS -97, no. 2 , March/April 1978).
"""


def bartky(d1=0, d2=0, h1=0, h2=0, n1=0, n2=0, z1=0, z2=0, i1=0, i2=0, sinal1=1, sinal2=1, force=False):
    if n1*n2*d1*d2 == 0:
        return 0
    dc = abs(z1-z2)
    r1, r2 = d1/2000, d2/2000
    z = np.array([((h1+h2)/2+dc)/1000, ((h1-h2)/2+dc)/1000,
                 ((-h1-h2)/2+dc)/1000, ((-h1+h2)/2+dc)/1000], dtype='float32')
    k, m, Ci, n = 0, 0, 0, 4
    if dc == 0:
        if r1 != r2:
            n = 2
        else:
            n = 1
    q = (r1-r2)/(r1+r2)

    for k in range(1, n+1, 1):
        zz = z[k-1]
        k2 = ((r1-r2)**2+zz**2)/((r1+r2)**2+zz**2)
        gama = zz**2/(4*r1*r2)
        A = math.sqrt(1-k2)*(-gama+1/(3*(1-k2)))
        B = -k2/(3*math.sqrt(1-k2))
        C = gama*math.sqrt(1-k2)
        if not force:
            if r1 == r2:
                A, B, C = A+C, B+C, 0
        else:
            A, B, C = -1, 0, 1
            if r1 == r2:
                A, B, C = 0, 1, 0
        d = 0
        alfa0, beta0, q0 = 1, math.sqrt(k2), abs(q)
        alfaj, betaj, qj = alfa0, beta0, q0
        A0, B0, C0, D0 = A, B, C, 0
        AJ, BJ, CJ, DJ = A0, B0, C0, D0
        loop = 0
        teste = False
        erro = 1
        while not (teste):
            alfaj = alfa0+beta0
            betaj = 2*math.sqrt(alfa0*beta0)
            AJ = B0/alfa0+A0
            BJ = 2*(B0+beta0*A0)
            CJ = 0
            DJ = 0
            if q0 != 0:
                qj = q0+alfa0*beta0/q0
                CJ = C0+D0/q0
                DJ = 2*(alfa0*beta0*C0/q0+D0)
            erro = abs(1-betaj/alfaj)
            teste = (abs(erro) <= 1e-15)
            if not teste:
                alfa0 = alfaj
                beta0 = betaj
                q0 = qj
                A0 = AJ
                B0 = BJ
                C0 = CJ
                D0 = DJ
            loop += 1
        if force:
            Ci = ((alfaj*AJ+BJ)/(2*alfaj**2)+(CJ*alfaj+DJ)/(alfaj*(alfaj+qj))) * \
                math.cos((k+1)*math.pi)*3*math.pi**2/16 * \
                zz*math.sqrt((1-k2)/(r1*r2))+Ci
        else:
            Ci = ((AJ*alfaj+BJ)/(2*alfaj**2)+(CJ*alfaj+DJ) /
                  (alfaj*(alfaj+qj)))*math.cos((k+1)*math.pi)+Ci
        # print(Ci, erro)
    if not force:
        if dc == 0:
            if r1 != r2:
                # , loop, erro
                return math.cos((sinal1-sinal2)*math.pi/180)*16*math.pi**2*n1/h1*n2/h2*math.pow(r1*r2, 1.5)*Ci*100
            else:
                # , loop, erro
                return math.cos((sinal1-sinal2)*math.pi/180)*16*math.pi**2*n1/h1*n2/h2*math.pow(r1*r2, 1.5)*(Ci-2/(3*math.pi))*100
        else:
            # , loop, erro
            return math.cos((sinal1-sinal2)*math.pi/180)*8*math.pi**2*n1/h1*n2/h2*(r1*r2)**1.5*Ci*100
    else:
        return abs(0.4*math.pi*i1*i2*n1*n2/(9.8*h1*h2)*Ci)


"""# Função para cálculo do campo magnético devido a um enrolamento helicoidal pela lei de Biot Savart.
* Resultados kA/m desde de que as dimensões e coordenadas sejam dadas em mm.
* Função para calcular o campo magnético de cada enrolamento em dada coordenada (R, Z).
* Requerida no cálculo de perdas induzidas, hoop stress devido ao campo axial e compressão devido ao campo radial.

\begin{align}
        &\bar{H} = \frac{1}{4π}\int_{C}\frac{I\mathrm{dl}⊗\bar{u'}}{|\bar{r}|²}
        &\bar{B} = \mu_0\bar{H}        
    \end{align}
1.   H é o vator intesidade de campo magnético em A/m.
2.   B é o vetor indução magnética em T (Tesla).
  
* A lei de Biot-Savart é usada para calcular o vetor campo magnético indução B no vator coordenada r em um espaço 3D gerado por um corrente I conduzida no caminhor do condutor/enrolamento.
*  Em enrolamentos helicodais o campo é campos de duas componentes sendo uma radial e outra axial respecitivamente Hr, Hz, Br, Bz.
* Cada enrolamento está sujeito forças eletromagnéticas regidas pelas seguintes equações:

\begin{align}
\bar{F} = i×\bar{l}\otimes\bar{B}
\end{align}
\begin{align}
i(t) = I_0\times e^\frac{-Rt}{L}+Imax\times cos(ωt) 
\end{align}
\begin{align}
\bar{f(t)} = Fmax\times( \frac{1}{2}+e^\frac{-2Rt}{L}+\frac{1}{2}cos(2ωt) )
\end{align}

* Está força é composta de duas componentes, uma na direção radial e outra na direção axial. A força radial causada pelo campo axial causa um stress conhecido como hoop stress e força axial causada pelo campo radial atua no enrolamento na forma de um stress de compressão.
* O valores de stress são calculados, verificados e controlados através do apicativo de dimensionamento garantido que os limites impostos pelos guideslines internos de engenharia não sejam utrapassados. O campo magnético é mapeado em coordenadas localizadas nos diversos enrolamentos do reator sendo estes campos utilizados para calcular as perdas induzidas e os stress. 
  
"""

# !pip install  ipdb

# import ipdb as deb


def campo(corrente, nesp=1, dm=0, he=0, esp=0, r=0, z=0, ang1=0, ang2=0):
    def f(a):
        if a == 0:
            a = 1e-30
        return 1.38629436+a*(0.096663443+a*(0.0359000924+a*(0.037425637 +
                                                            0.0145112962*a)))-np.log(a)*(0.5+a*(0.12498594+a*(0.068802486+a *
                                                                                                              (0.033283553+0.0044178701*a))))

    def e(a):
        if a == 0:
            a = 1e-30
        return 1+a*(0.44325141+a*(0.062606012+a*(0.047573836+0.017365065*a))) -\
            np.log(a)*a*(0.24998368+a*(0.0920018+a*(0.040696975 +
                                                    0.0052644964*a)))

    def q(a, b):
        pm = 1
        pn = np.sqrt(1-b)
        if pn == 0:
            pn = 1e-20
        p = a+1
        if p > 0:
            pp = np.sqrt(p)
            cc = 1
            dd = 1/pp
        else:
            pp = np.sqrt((1-b-p)/np.sqrt(1-p))
            cc = 0
            if pp == 0:
                pp = 1e-20
            dd = -b/(pp*(1-p))
        pnn = pn
        pmm = pm
        while (np.abs(1-pnn/pmm) > 1e-8):
            pmm = pm
            pnn = pn
            ppp = pp
            ccc = cc
            ddd = dd
            pm = pmm+pnn
            pn = 2*np.sqrt(pnn*pmm)
            pp = pnn*pmm/ppp+ppp
            cc = ddd/ppp+ccc
            dd = 2*(pnn*pmm*ccc/ppp+ddd)
        return np.pi/2*(cc*pm+dd)/(pm*(pm+pp))

    def f1(u1, u2, b2, v2, b1, v1):
        return u2*f(1-b2)-v2*e(1-b2)-u1*f(1-b1)+v1*e(1-b1)

    def f2(m1, m2, b2, n, a, b1):
        return m2*(f(1-b2)-n*q(a, b2))-m1*(f(1-b1)-n*q(a, b1))
    # Resultado em kArms/m se dimensoes em mm e corrente em amperes

    h = esp/4
    ro = dm/2-2*h
    z2 = he/2
    z1 = -z2
    hrr = 0
    hzz = 0
    for i in range(1, 6):
        v1 = np.sqrt((z1-z)**2+(ro+abs(r))**2)
        v2 = np.sqrt((z2-z)**2+(ro+abs(r))**2)
        u1 = (ro**2+r**2+(z1-z)**2)/v1
        u2 = (ro**2+r**2+(z2-z)**2)/v2
        b1 = 4*np.abs(r)*ro/v1**2
        b2 = 4*np.abs(r)*ro/v2**2
        m1 = (z1-z)/v1
        m2 = (z2-z)/v2
        n = (abs(r)-ro)/(abs(r)+ro)
        a = -4*abs(r)*ro/(ro+abs(r))**2
        # deb.set_trace(context=20)
        if i == 1 or i == 5:
            k = 1
        elif i == 2 or i == 4:
            k = 4
        elif i == 3:
            k = 2
        hrr = k*f1(u1, u2, b2, v2, b1, v1)+hrr
        hzz = k*f2(m1, m2, b2, n, a, b1)+hzz
        ro = ro+h
        if r != 0:
            Hr = nesp*corrente/(2*np.pi*esp*r*he)*hrr*h/3
        else:
            Hr = 0
    return Hr, nesp*corrente/(2*np.pi*esp*he)*hzz*h/3


def FatorTM(a, b, delta, f):
    EixoX = a*b/(delta)
    EixoXLog = np.log10(EixoX)
    razaocruz = b/a
    LogRazaoCruz = np.log10(razaocruz)
    c = -0.2281807953*LogRazaoCruz**4+0.4543346789 * \
        LogRazaoCruz**3+0.3866080182*LogRazaoCruz**2
    +0.6973115099*LogRazaoCruz+1.1295290359
    result = 10**(-1.47545*EixoXLog+c)
    if result > 1:
        result = 1
    if (f < 1000) and (1/razaocruz > 5):
        result = 1
    return result


def F(x):
    result = x*(np.sinh(2*x)+np.sin(2*x))/(np.cosh(2*x)-np.cos(2*x))
    if result < 1:
        result = 1
    return result


def OtimizedG(x, wireDist, layerDist):
    '''Based on Simplified High-Accuracy Calculation of Eddy-Current Losses Paper by Xi Nan and C. R. Sulivan'''
    def G1(x, k):
        '''Based on Simplified High-Accuracy Calculation of Eddy-Current Losses Paper by Xi Nan and C. R. Sulivan'''
        return 3*np.pi/16*k**-3*(np.sinh(k*x)-np.sin(k*x))/(np.cosh(k*x)+np.cos(k*x))

    def G2(x, b):
        '''Based on Simplified High-Accuracy Calculation of Eddy-Current Losses Paper by Xi Nan and C. R. Sulivan'''
        return np.pi*x/(32*(x**-3+b**3))

    def wn(c, u1, u0, y0, y, sinal):
        return c+sinal*(u1-u0*np.exp(-y/y0))**2

    def w(wireDist, layerDist):
        return wireDist*wn(0.0596, 0.1558, 0.3477, 1.0673, wireDist, -1)+wn(0.0018, 0.1912, 0.2045, 1.3839, layerDist, 1)

    def Ffunction(s1, s2, q, y):
        '''Based on Simplified High-Accuracy Calculation of Eddy-Current Losses Paper by Xi Nan and C. R. Sulivan'''
        return (s1-s2)/(1/y+1/q)+s2

    b = Ffunction(wireDist, Ffunction(layerDist, -0.0037, 0.0432, -0.0661), Ffunction(
        layerDist, 1.8167, 0.0074, 0.2195), Ffunction(layerDist, 0.7053, 0.8378, 23.8755))
    k = Ffunction(layerDist, Ffunction(wireDist, 1.0261, 0.8149, 9.3918), Ffunction(
        wireDist, 0.4742, 0.8023, 1.2225), Ffunction(wireDist, 0.093, 0.2588, -0.0334))
    return (1-w(wireDist, layerDist))*G1(x, k)+w(wireDist, layerDist)*G2(x, b)


def compress(enrols=pd.DataFrame, ndiv=11, ipeak_in=1.0):
    compress = []
    for index, enrol in enrols.iterrows():
        he = enrol['Altura do enrolamento']
        z = he/(ndiv*4)-he/2
        l = 1/(ndiv*2)
        r = enrol['Diâmetro médio']/2
        dmed = enrol['Diâmetro médio']
        esp = enrol['Espessura']
        cs = 0
        for i in range(ndiv):
            hr, _ = reactor_field(enrols, r, z)
            cs += cs+np.abs(hr)*(1+21/(2*ndiv))*0.01/(ndiv)**2*np.pi*dmed/2
        compress.append(cs)
    compress = compress*enrols['# Espiras']*enrols['Corrente (A)']*ipeak_in**2*mi0()/(
        enrols['Diâmetro médio']*enrols['espessura']*enrols['Fios radiais'].astype('int'))
    enrols['Compressão (Mpa)'] = compress
    max_compress = max(np.abs(compress))
    return enrols, max_compress


def hoop(enrols=pd.DataFrame, ipeak_in=1.0):
    hoop = []
    for index, enrol in enrols.iterrows():
        he = enrol['Altura do enrolamento']
        # z = he/(ndiv*4)-he/2
        # l = 1/(ndiv*2)
        r = enrol['Diâmetro médio']/2
        dmed = enrol['Diâmetro médio']
        esp = enrol['Espessura']
        _, hz = reactor_field(enrols, r, 0)
        hs = np.abs(hz)*np.pi*dmed/2
        hoop.append(hs)
    hoop = hoop*enrols['# Espiras']*enrols['Corrente (A)']*ipeak_in**2*mi0()/(
        enrols['Diâmetro médio']*enrols['espessura']*enrols['Fios radiais'].astype('int'))
    enrols['Hoop (Mpa)'] = hoop
    max_hoop = max(np.abs(hoop))
    return enrols, max_hoop


def ind_losses(enrols=pd.DataFrame, ndiv=11, frq=60, ro=0.027898):
    w = 2*np.pi*frq
    total_pad = 0
    pad_cil = []
    for index, enrol in enrols.iterrows():
        dfio = enrol['dfio nú medio (mm)']
        dfio_isol = enrol['dfio isol avg (mm)']
        espfio = (dfio_isol-dfio)/dfio
        delta = np.sqrt(2*ro/(np.pi*4e-7*w))
        episolon = np.sqrt(np.pi)*dfio/2/delta
        g = np.sqrt(2)/delta
        sigma = dfio/2*g
        he = enrol['Altura do enrolamento']
        z = he/(ndiv*4)-he/2
        l = 1/(ndiv*2)
        r = enrol['Diâmetro médio']/2
        esp = enrol['Espessura']
        pad = 0
        for i in range(2*ndiv):
            hri, hzi = reactor_field(enrols, r-esp, z)
            hro, hzo = reactor_field(enrols, r+esp, z)
            fieldModMaxIn = np.sqrt(hri**2+hzi**2) * \
                np.sqrt(2)*1000  # Campo em A/m
            fieldModMaxOut = np.sqrt(hro**2+hzo**2)*np.sqrt(2)  # Campo em A/m
            pad += 1/2*he*ro*l/delta*((fieldModMaxIn-fieldModMaxOut)**2*(F(episolon)-1) +
                                      2*fieldModMaxIn*fieldModMaxOut*OtimizedG(episolon, espfio, espfio))
        # enrol['Pad (W)'] = pad*enrol['Fios axiais']*enrol['Fios axiais']*r
        total_pad += pad*int(enrol['Fios axiais']) * \
            int(enrol['Fios radiais'])*2*np.pi*r*1e-9
        pad_cil.append(pad*int(enrol['Fios axiais'])
                       * int(enrol['Fios radiais'])*2*np.pi*r*1e-9)
    enrols['Pad (W)'] = pad_cil
    return enrols, total_pad


def dubell(cils: pd.DataFrame):
    for index, enrol in cils.iterrows():
        pass

    pass


def heat_constant(ncil, dbs, duct, classtemp):
    dbs /= 25.4
    if ncil == 1:
        return [5.5]
    elif ncil == 2:
        if dbs > 20:
            return [6.0, 6.0]
        else:
            return [7.0, 7.0]
    else:
        hc = []
        for i in range(ncil):
            if i == 0 or i == ncil-1:
                if dbs > 20:
                    hc.append(6.0)
                else:
                    hc.append(7.0)
            else:
                if dbs > 20:
                    if classtemp == 130:
                        hc1 = -0.000076687*dbs**3+0.013420394*dbs**2 - 0.764304824*dbs + 23.360316400
                        if np.abs(hc1) > 8.5:
                            hc.append(8.5)
                        elif np.abs(hc1) < 6:
                            hc.append(8.5)
                        else:
                            hc.append(hc1)
                    else:
                        hc1 = -0.000106954*dbs**3+0.018056904*dbs**2 - 0.965401878*dbs + 25.216160537
                        if np.abs(hc1) > 8.5:
                            hc.append(8.5)
                        elif np.abs(hc1) < 6:
                            hc.append(6.5)
                        else:
                            hc.append(hc1)
                else:
                    hc.append(13.0)
        return hc


def reactor_field(enrols=pd.DataFrame, r=0, z=0):
    hr_total = 0
    hz_total = 0
    # deb.set_trace(context=20)
    for index, enrol in enrols.iterrows():
        corrente = np.abs(enrol['Corrente (A)'])
        hr, hz = campo(corrente, enrol['# Espiras'], enrol['Diâmetro médio'],
                       enrol['Altura do enrolamento'], enrol['Espessura'], r, z)
        hr_total += hr
        hz_total += hz
    return hr_total, hz_total


def result_by_cil(camadas: pd.DataFrame):
    return camadas.groupby(
        ['Cilindro']
    ).agg(
        {
            '# Espiras': "mean",
            'Altura do enrolamento': "mean",
            'Diâmetro médio': "mean",
            'Corrente (A)': "sum",
            'Perdas (W)': "sum",
            'Z(mm)': "mean",
            'Peso fio (kg)':"sum"
        }
    )

# cils = pd.read_excel('bree prototipo Di = 1200 mm.xlsx',sheet_name=3, engine='openpyxl',dtype={'Cilindro': int, 'Corrente (A)': complex})
# cils[['Cilindro','# Espiras','Altura do enrolamento','Diâmetro médio','Espessura','Corrente (A)']]

# field = reactor_field(cils,398.45/2,1226.10/2)
# field

# def mapmag():
#     n = 49
#     rs = np.linspace(-2000,2000,n)
#     zs = np.linspace(-1000,1000,n)
#     i = 0
#     fields = np.zeros((rs.shape[0],zs.shape[0]),dtype=float)
#     for r in rs:
#         j = 0
#         for z in zs:
#             field = np.abs(reactor_field(cils,r,z))
#             field_R = field[0]
#             field_Z =  field[1]
#             field_res = float(np.sqrt(field_R**2+field_Z**2))#float(field_R)#
#             if i<n and j<n:
#                fields[i,j] = field_res
#             j += 1
#         i += 1
    # plotting the heatmap
    # ax.set_xticklabels(rs)
    # ax.set_yticklabels(zs)
    hm = sns.heatmap(data=fields, cmap="RdBu", square=True)

    # displaying the plotted heatmap
    plt.show()
    # fig, ax = plt.subplots()

    # im = ax.imshow(fields)

   # ax.set_xticks(np.arange(n))
   # ax.set_yticks(np.arange(n))

   # ax.set_xticklabels(rs)
   # ax.set_yticklabels(zs)

   # plt.setp(ax.get_xticklabels(), rotation=90, ha="right", rotation_mode="anchor")

   # ax.set_title("Field Distribution")

    # plt.show()
    pass

# mapmag()

# cams = pd.read_excel('bree prototipo Di = 1200 mm.xlsx',sheet_name=1, engine='openpyxl')
# cams[['Cilindro', '# Espiras','Altura do enrolamento','Diâmetro médio','RMS (A)','Corrente (A)']]
# %%
